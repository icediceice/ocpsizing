<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenShift Resource Planning Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-direction: column;
        }

        .input-section {
            padding: 40px;
            background: #f8f9fa;
            border-bottom: 3px solid #ee0979;
        }

        .results-section {
            padding: 40px;
            background: white;
            position: relative;
        }

        .results-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 40px;
            right: 40px;
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, #e9ecef 50%, transparent 100%);
        }

        .section-title {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 3px solid #ee0979;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #ee0979;
            box-shadow: 0 0 0 3px rgba(238, 9, 121, 0.1);
        }

        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .radio-option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .radio-option:hover {
            border-color: #ee0979;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .radio-option.selected {
            border-color: #ee0979;
            background: linear-gradient(135deg, #ee0979, #ff6a00);
            color: white;
        }

        .radio-option.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #f8f9fa;
            color: #6c757d;
        }

        .radio-option.disabled:hover {
            transform: none;
            box-shadow: none;
            border-color: #e9ecef;
        }
        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option h3 {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .radio-option p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .radio-option label {
            cursor: pointer;
        }

        .checkbox-group {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-item:last-child {
            margin-bottom: 0;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
            transform: scale(1.2);
        }

        .workload-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .workload-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .workload-content {
            padding: 20px;
        }

        .workload-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        .workload-item:last-child {
            margin-bottom: 0;
        }

        .workload-inputs {
            display: grid;
            grid-template-columns: 1.8fr 0.8fr 0.8fr 1fr 1.2fr;
            gap: 15px;
            align-items: end;
        }

        .workload-field {
            display: flex;
            flex-direction: column;
        }

        .workload-field label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .workload-field input, .workload-field select {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .workload-field input:focus, .workload-field select:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 2px rgba(79, 172, 254, 0.1);
        }

        .remove-workload {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
        }

        .remove-workload:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .add-workload-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 15px;
        }

        .add-workload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 10px rgba(79, 172, 254, 0.3);
        }

        .logging-storage-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
        }

        .logging-storage-header {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logging-storage-content {
            padding: 20px;
            display: none;
        }

        .logging-storage-content.active {
            display: block;
        }

        .storage-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .growth-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }

        .growth-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .growth-content {
            padding: 20px;
            display: none;
        }

        .growth-content.active {
            display: block;
        }

        .growth-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .calculate-btn {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease;
            width: 100%;
            margin-top: 30px;
        }

        .export-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease;
            margin-left: 15px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .btn-container {
            display: flex;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        .btn-container .calculate-btn {
            flex: 1;
            margin: 0;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(238, 9, 121, 0.3);
        }

        .result-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .result-card h3 {
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .warning {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b95 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
        }

        .success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
        }
        
        .result-card .status-icon {
            font-size: 1.5rem;
            margin-right: 10px;
        }


        .info-tooltip {
            display: inline-block;
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            cursor: help;
            line-height: 20px;
        }

        .breakdown-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .breakdown-title {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .breakdown-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .breakdown-item:last-child {
            border-bottom: none;
        }

        .storage-breakdown {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .growth-chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .growth-projections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .projection-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
        }

        .projection-card h4 {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .projection-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .recommendation-card {
            background: linear-gradient(135deg, #ff6b95 0%, #ff9a56 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .recommendation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
        }

        .recommendation-status {
            font-weight: bold;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .status-urgent { background: #dc3545; }
        .status-warning { background: #ffc107; color: #000; }
        .status-caution { background: #fd7e14; }
        .status-ok { background: #28a745; }

        .reset-btn {
            background: linear-gradient(135deg, #6c757d 0%, #343a40 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-left: 15px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .reset-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(108, 117, 125, 0.3);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .radio-group {
                grid-template-columns: 1fr;
            }

            .workload-inputs {
                grid-template-columns: 1fr;
            }

            .growth-inputs, .storage-inputs {
                grid-template-columns: 1fr;
            }

            .growth-projections {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 OpenShift Resource Calculator</h1>
            <p>Plan your cluster resources with precision - including multiple workloads, logging, monitoring, storage requirements, and growth projections</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <!-- NEW: Mode Selector -->
                <div class="form-group">
                    <label>Select Calculator Mode</label>
                    <div class="radio-group" id="mode-selector">
                        <div class="radio-option selected" onclick="switchMode('sizing', this)">
                            <input type="radio" id="modeSizing" name="calculatorMode" value="sizing" checked>
                            <label for="modeSizing">
                                <h3>Resource Sizing</h3>
                                <p>Calculate infrastructure needed for your workloads.</p>
                            </label>
                        </div>
                        <div class="radio-option" onclick="switchMode('capacity', this)">
                            <input type="radio" id="modeCapacity" name="calculatorMode" value="capacity">
                            <label for="modeCapacity">
                                <h3>Capacity Estimator</h3>
                                <p>Estimate workloads an existing infrastructure can support.</p>
                            </label>
                        </div>
                    </div>
                </div>

                <div id="sizing-calculator-inputs">
                    <!-- Multiple Workload Specifications -->
                    <div class="workload-section">
                        <div class="workload-header">
                            <span>💻 Step 1: Define Your Workloads</span>
                        </div>
                        <div class="workload-content">
                            <div id="workloads-container">
                                <!-- Workloads will be dynamically added here -->
                            </div>
                            <button class="add-workload-btn" onclick="addWorkload()">➕ Add Workload Type</button>
                        </div>
                    </div>

                    <!-- Worker Node Specifications -->
                    <h3 style="margin: 30px 0 20px 0; color: #333;">⚙️ Step 2: Configure Your Infrastructure</h3>

                    <div class="form-group">
                        <label for="cpuCores">Physical CPU Cores per Node: <span class="info-tooltip" title="Physical CPU cores available on each worker node">?</span></label>
                        <input type="number" id="cpuCores" value="8" min="1" onchange="saveInputsToLocalStorage()">
                    </div>

                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="customizeSockets" onchange="toggleSocketInput(); saveInputsToLocalStorage();">
                            <label for="customizeSockets">Customize Sockets per Node (Default: 2)</label>
                        </div>
                        <!-- This input is always in the DOM, just not visible by default. Its value is used in calculations. -->
                        <input type="number" id="socketsPerNode" value="2" min="1" style="display: none; margin-top: 10px;" onchange="saveInputsToLocalStorage()">
                    </div>

                    <div class="form-group">
                        <label for="cpuToVcpuRatio">CPU to vCPU Ratio: <span class="info-tooltip" title="How many vCPUs per physical CPU core (e.g., 2 = hyperthreading)">?</span></label>
                        <input type="number" id="cpuToVcpuRatio" value="2" min="1" step="0.1" onchange="saveInputsToLocalStorage()">
                    </div>

                    <div class="form-group">
                        <label for="memoryPerNode">Memory per Node (GB): <span class="info-tooltip" title="Total memory available on each worker node">?</span></label>
                        <input type="number" id="memoryPerNode" value="32" min="1" onchange="saveInputsToLocalStorage()">
                    </div>

                    <div class="form-group">
                        <label for="maxUtilization">Max Host Utilization (%): <span class="info-tooltip" title="Maximum resource utilization before provisioning new nodes">?</span></label>
                        <input type="number" id="maxUtilization" value="80" min="50" max="95" onchange="saveInputsToLocalStorage()">
                    </div>
                    
                    <!-- Cluster Configuration Options -->
                    <div class="form-group">
                        <label>Cluster Configuration:</label>
                        <div class="checkbox-group">
                            <div class="checkbox-item">
                                <input type="checkbox" id="mergeMasters" onchange="saveInputsToLocalStorage()">
                                <label for="mergeMasters">Merge Master nodes with Worker nodes (Compact cluster)</label>
                            </div>
                        </div>
                    </div>

                    <h3 style="margin: 30px 0 20px 0; color: #333;">🚀 Step 3: Advanced Configuration (Optional)</h3>

                    <!-- Logging Stack Selection -->
                    <div class="form-group">
                        <label>Choose Logging Stack:</label>
                        <div class="radio-group">
                            <div class="radio-option selected" onclick="selectLoggingStack('elasticsearch', this)">
                                <input type="radio" id="logStackEs" name="loggingStack" value="elasticsearch" checked>
                                <label for="logStackEs">
                                    <h3>Elasticsearch</h3>
                                    <p>Higher infra resources, lower per-node overhead</p>
                                </label>
                            </div>
                            <div class="radio-option" onclick="selectLoggingStack('loki', this)">
                                <input type="radio" id="logStackLoki" name="loggingStack" value="loki">
                                <label for="logStackLoki">
                                    <h3>LokiStack</h3>
                                    <p>Lower infra resources, higher per-node overhead</p>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Subscription Type Selection -->
                    <div class="form-group">
                        <label>OpenShift Subscription Type:</label>
                        <div class="radio-group" id="subscription-type-selector">
                            <div class="radio-option selected" onclick="selectSubscriptionType('core', this)">
                                <input type="radio" id="subTypeCore" name="subscriptionType" value="core" checked>
                                <label for="subTypeCore">
                                    <h3>Core-based</h3>
                                    <p>1 subscription per 2 physical cores.</p>
                                </label>
                            </div>
                            <div class="radio-option" onclick="selectSubscriptionType('socket', this)">
                                <input type="radio" id="subTypeSocket" name="subscriptionType" value="socket">
                                <label for="subTypeSocket">
                                    <h3>Bare-metal (Socket-based)</h3>
                                    <p>Up to 128 cores & 2 sockets per subscription.</p>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Logging Storage Configuration -->
                    <div class="logging-storage-section">
                        <div class="logging-storage-header" onclick="toggleLoggingStorageSection()">
                            <span>💾 Logging Storage Configuration</span>
                            <span id="storageToggle">▼</span>
                        </div>
                        <div class="logging-storage-content" id="storageContent">
                            <div class="storage-inputs">
                                <div class="form-group">
                                    <label for="logVolumePerPod">Log Volume per Pod (MB/day): <span class="info-tooltip" title="Average log volume generated per pod per day">?</span></label>
                                    <input type="number" id="logVolumePerPod" value="100" min="1" onchange="saveInputsToLocalStorage()">
                                </div>
                                <div class="form-group">
                                    <label for="logRetentionDays">Log Retention (Days): <span class="info-tooltip" title="How long to keep logs before deletion">?</span></label>
                                    <input type="number" id="logRetentionDays" value="30" min="1" max="365" onchange="saveInputsToLocalStorage()">
                                </div>
                                <div class="form-group">
                                    <label for="compressionRatio">Compression Ratio: <span class="info-tooltip" title="Log compression factor (2 = 50% compression)">?</span></label>
                                    <input type="number" id="compressionRatio" value="3" min="1" max="10" step="0.1" onchange="saveInputsToLocalStorage()">
                                </div>
                                <div class="form-group">
                                    <label for="replicationFactor">Replication Factor: <span class="info-tooltip" title="Number of copies for HA (Elasticsearch only)">?</span></label>
                                    <input type="number" id="replicationFactor" value="1" min="1" max="3" onchange="saveInputsToLocalStorage()">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Growth Projection Module -->
                    <div class="growth-section">
                        <div class="growth-header" onclick="toggleGrowthSection()">
                            <span>📈 Growth Projection</span>
                            <span id="growthToggle">▼</span>
                        </div>
                        <div class="growth-content" id="growthContent">
                            <div class="form-group">
                                <div class="checkbox-item">
                                    <input type="checkbox" id="enableGrowth" onchange="toggleGrowthInputs(); saveInputsToLocalStorage();">
                                    <label for="enableGrowth">Enable Growth Projections</label>
                                </div>
                            </div>
                            <div id="growthInputs" style="display: none;">
                                <div class="growth-inputs">
                                    <div class="form-group">
                                        <label for="growthRate">Annual Growth Rate (%):</label>
                                        <input type="number" id="growthRate" value="50" min="0" max="200" step="1" onchange="saveInputsToLocalStorage()">
                                    </div>
                                    <div class="form-group">
                                        <label for="projectionMonths">Projection Period (Months):</label>
                                        <input type="number" id="projectionMonths" value="12" min="1" max="60" onchange="saveInputsToLocalStorage()">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="btn-container">
                        <button class="calculate-btn" onclick="calculateResources()">🔢 Calculate Resources</button>
                        <button class="export-btn" onclick="exportToExcel()" id="exportBtn" style="display: none;">📊 Export to Excel</button>
                        <button class="reset-btn" onclick="resetToDefaults()" title="Reset all inputs to default values">🔄 Reset</button>
                    </div>
                </div>

                <div id="capacity-estimator-inputs" style="display: none;">
                    <h3 style="margin: 30px 0 20px 0; color: #333;">🏗️ Step 1: Define Your Infrastructure</h3>
                    <div class="form-group">
                        <label for="capacityWorkerNodes">Number of Worker Nodes:</label>
                        <input type="number" id="capacityWorkerNodes" value="3" min="1" onchange="saveInputsToLocalStorage()">
                    </div>
                    <div class="form-group">
                        <label for="capacityCpuCores">Physical CPU Cores per Node:</label>
                        <input type="number" id="capacityCpuCores" value="8" min="1" onchange="saveInputsToLocalStorage()">
                    </div>
                    <div class="form-group">
                        <label for="capacityMemoryPerNode">Memory per Node (GB):</label>
                        <input type="number" id="capacityMemoryPerNode" value="32" min="1" onchange="saveInputsToLocalStorage()">
                    </div>

                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="capacityCustomizeSockets" onchange="toggleCapacitySocketInput(); saveInputsToLocalStorage();">
                            <label for="capacityCustomizeSockets">Customize Sockets per Node (Default: 2)</label>
                        </div>
                        <input type="number" id="capacitySocketsPerNode" value="2" min="1" style="display: none; margin-top: 10px;" onchange="saveInputsToLocalStorage()">
                    </div>

                    <!-- Subscription Type Selection -->
                    <div class="form-group">
                        <label>OpenShift Subscription Type:</label>
                        <div class="radio-group" id="capacity-subscription-type-selector">
                            <div class="radio-option selected" onclick="selectSubscriptionType('core', this)">
                                <input type="radio" id="capSubTypeCore" name="capacitySubscriptionType" value="core" checked>
                                <label for="capSubTypeCore">
                                    <h3>Core-based</h3>
                                    <p>1 subscription per 2 physical cores.</p>
                                </label>
                            </div>
                            <div class="radio-option" onclick="selectSubscriptionType('socket', this)">
                                <input type="radio" id="capSubTypeSocket" name="capacitySubscriptionType" value="socket">
                                <label for="capSubTypeSocket">
                                    <h3>Bare-metal (Socket-based)</h3>
                                    <p>Up to 128 cores & 2 sockets per subscription.</p>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="btn-container">
                        <button class="calculate-btn" onclick="calculateCapacity()">🔍 Estimate Capacity</button>
                        <button class="reset-btn" onclick="resetToDefaults()" title="Reset all inputs to default values">🔄 Reset</button>
                    </div>
                </div>
            </div>

            <div class="results-section">
                <h2 class="section-title">📈 Results</h2>
                <div id="results-container">
                    <div class="result-card">
                        <h3>👋 Welcome!</h3>
                        <p>Configure your cluster specifications on the left and click "Calculate Resources" to see detailed resource planning recommendations.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedLoggingStack = 'elasticsearch';
        let workloadCounter = 0;
        let workloads = [];
        let currentMode = 'sizing';
        let selectedSubscriptionType = 'core';
        const LOCAL_STORAGE_KEY = 'openShiftSizingCalculatorInputs';

        const WORKLOAD_PRESETS = {
            container: { name: 'Typical Container', vcpu: 0.5, memory: 1 },
            vm: { name: 'Typical VM', vcpu: 2, memory: 4 }
        };

        // Initialize with one default workload
        function initializeWorkloads() {
            if (workloads.length === 0) {
                addWorkload();
            }
        }

        /**
         * @description Handles the selection of the subscription type.
         * @param {string} type - The selected subscription type ('core' or 'socket').
         * @param {HTMLElement} element - The clicked radio option element.
         */
        function selectSubscriptionType(type, element) {
            if (element.classList.contains('disabled')) {
                return;
            }
            selectedSubscriptionType = type;
            
            // Update UI selection
            element.parentElement.querySelectorAll('.radio-option').forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
            element.querySelector('input[type="radio"]').checked = true;
            saveInputsToLocalStorage();
        }

        function selectLoggingStack(stack, element) {
            selectedLoggingStack = stack;
            
            // Update UI
            element.parentElement.querySelectorAll('.radio-option').forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
            
            // Update radio button
            element.querySelector('input[type="radio"]').checked = true;
            saveInputsToLocalStorage();
        }

        function toggleSocketInput() {
            const customizeSockets = document.getElementById('customizeSockets').checked;
            const socketInput = document.getElementById('socketsPerNode');
            
            socketInput.style.display = customizeSockets ? 'block' : 'none';
            
            if (!customizeSockets) {
                socketInput.value = 2; // Reset to default when hiding
            }
        }

        function toggleCapacitySocketInput() {
            const customizeSockets = document.getElementById('capacityCustomizeSockets').checked;
            const socketInput = document.getElementById('capacitySocketsPerNode');
            
            socketInput.style.display = customizeSockets ? 'block' : 'none';
            
            if (!customizeSockets) {
                socketInput.value = 2; // Reset to default when hiding
            }
        }

        function toggleLoggingStorageSection() {
            const content = document.getElementById('storageContent');
            const toggle = document.getElementById('storageToggle');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                toggle.textContent = '▼';
            } else {
                content.classList.add('active');
                toggle.textContent = '▲';
            }
        }

        function toggleGrowthSection() {
            const content = document.getElementById('growthContent');
            const toggle = document.getElementById('growthToggle');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                toggle.textContent = '▼';
            } else {
                content.classList.add('active');
                toggle.textContent = '▲';
            }
        }

        function toggleGrowthInputs() {
            const enableGrowth = document.getElementById('enableGrowth').checked;
            const growthInputs = document.getElementById('growthInputs');
            growthInputs.style.display = enableGrowth ? 'block' : 'none';
        }

        function addWorkload(workload = null) {
            workloadCounter++;
            const workloadId = `workload-${workloadCounter}`;
            
            const isNew = !workload;
            const type = isNew ? 'container' : workload.type;
            const preset = WORKLOAD_PRESETS[type];
            const name = isNew ? preset.name : workload.name;
            const instances = isNew ? 50 : workload.instances;
            const vcpu = isNew ? preset.vcpu : workload.vcpu;
            const memory = isNew ? preset.memory : workload.memory;
            
            const workloadHTML = `
                <div class="workload-item" id="${workloadId}">
                    <button class="remove-workload" onclick="removeWorkload('${workloadId}')" title="Remove workload">×</button>
                    <div class="workload-inputs">
                        <div class="workload-field">
                            <label>Workload Name</label>
                            <input type="text" placeholder="e.g., Web Applications" value="${name}" data-field="name" onchange="updateWorkloads()">
                        </div>
                        <div class="workload-field">
                            <label>Type</label>
                            <select data-field="type" onchange="handleWorkloadTypeChange(this)">
                                <option value="container" ${type === 'container' ? 'selected' : ''}>Container</option>
                                <option value="vm" ${type === 'vm' ? 'selected' : ''}>VM</option>
                            </select>
                        </div>
                        <div class="workload-field">
                            <label>Instances</label>
                            <input type="number" placeholder="100" value="${instances}" min="1" data-field="instances" onchange="updateWorkloads()">
                        </div>
                        <div class="workload-field">
                            <label>vCPU/Instance</label>
                            <input type="number" placeholder="0.5" value="${vcpu}" min="0.1" step="0.1" data-field="vcpu" onchange="updateWorkloads()">
                        </div>
                        <div class="workload-field">
                            <label>Memory/Instance (GB)</label>
                            <input type="number" placeholder="1.0" value="${memory}" min="0.1" step="0.1" data-field="memory" onchange="updateWorkloads()">
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('workloads-container').insertAdjacentHTML('beforeend', workloadHTML);
            if (isNew) {
                updateWorkloads();
            }
        }
        
        function handleWorkloadTypeChange(selectElement) {
            const workloadItem = selectElement.closest('.workload-item');
            if (!workloadItem) return;

            const type = selectElement.value;
            const preset = WORKLOAD_PRESETS[type];

            if (preset) {
                workloadItem.querySelector('[data-field="name"]').value = preset.name;
                workloadItem.querySelector('[data-field="vcpu"]').value = preset.vcpu;
                workloadItem.querySelector('[data-field="memory"]').value = preset.memory;
            }

            updateWorkloads();
        }

        function removeWorkload(workloadId) {
            document.getElementById(workloadId).remove();
            updateWorkloads();
        }

        function updateWorkloads() {
            workloads = [];
            const workloadElements = document.querySelectorAll('.workload-item');
            
            workloadElements.forEach(element => {
                const workload = {
                    name: element.querySelector('[data-field="name"]').value || 'Unnamed Workload',
                    type: element.querySelector('[data-field="type"]').value,
                    instances: parseInt(element.querySelector('[data-field="instances"]').value) || 0,
                    vcpu: parseFloat(element.querySelector('[data-field="vcpu"]').value) || 0,
                    memory: parseFloat(element.querySelector('[data-field="memory"]').value) || 0
                };
                workloads.push(workload);
            });
            checkSubscriptionForVmWorkloads();
            saveInputsToLocalStorage();
        }

        function checkSubscriptionForVmWorkloads() {
            const hasVmWorkload = workloads.some(w => w.type === 'vm');
            const subscriptionSelector = document.getElementById('subscription-type-selector');
            const coreOption = subscriptionSelector.querySelector('div[onclick*="\'core\'"]');
            const socketOption = subscriptionSelector.querySelector('div[onclick*="\'socket\'"]');

            // Remove existing warning message if any
            const existingWarning = document.getElementById('vm-subscription-warning');
            if (existingWarning) {
                existingWarning.remove();
            }

            // Use classList to enable/disable the core option
            coreOption.classList.toggle('disabled', hasVmWorkload);
            coreOption.querySelector('input').disabled = hasVmWorkload;

            if (hasVmWorkload) {
                // Force selection to socket-based
                selectSubscriptionType('socket', socketOption);

                // Add a warning message
                const warningHTML = `
                    <div id="vm-subscription-warning" class="warning" style="margin-top: 15px;">
                        💡 OpenShift Virtualization (VMs) requires a Bare-metal (Socket-based) subscription. The subscription type has been automatically selected.
                    </div>
                `;
                subscriptionSelector.insertAdjacentHTML('afterend', warningHTML);
            }
        }

        /**
         * @description Calculates the required OpenShift subscriptions based on the cluster size and subscription model.
         * @param {string} type - The subscription type ('core' or 'socket').
         * @param {number} billableNodes - The number of nodes that count towards subscription (i.e., worker nodes).
         * @param {number} cpuCoresPerNode - The number of physical CPU cores per node.
         * @param {number} socketsPerNode - The number of physical sockets per node.
         * @returns {object} An object containing the subscription calculation details.
         */
        function calculateSubscriptions(type, billableNodes, cpuCoresPerNode, socketsPerNode) {
            const totalPhysicalCores = billableNodes * cpuCoresPerNode;
            const totalSockets = billableNodes * socketsPerNode;
            let subscriptions = 0;
            let calculationMethod = '';

            if (type === 'core') {
                // Core-based: 1 subscription per 2 physical cores.
                subscriptions = Math.ceil(totalPhysicalCores / 2);
                calculationMethod = `Core-based: ${totalPhysicalCores} total billable cores / 2 cores per subscription.`;
            } else if (type === 'socket') {
                // Bare-metal (Socket-based): The greater of (sockets/2) or (cores/128).
                const subsBySockets = Math.ceil(totalSockets / 2);
                const subsByCores = Math.ceil(totalPhysicalCores / 128);
                subscriptions = Math.max(subsBySockets, subsByCores);
                
                if (subsByCores > subsBySockets) {
                    calculationMethod = `Bare-metal (Core-limited): ${totalPhysicalCores} total billable cores / 128 cores per subscription.`;
                } else {
                    calculationMethod = `Bare-metal (Socket-limited): ${totalSockets} total billable sockets / 2 sockets per subscription.`;
                }
            }

            return {
                count: subscriptions,
                type: type === 'core' ? 'Core-based' : 'Bare-metal (Socket-based)',
                totalPhysicalCores,
                totalSockets,
                calculationMethod
            };
        }

        function calculateCpuReservation(totalCpuCores) {
            let reservation = 0;
            
            if (totalCpuCores >= 1) {
                reservation += 1 * 0.06; // First CPU: 6%
            }
            if (totalCpuCores >= 2) {
                reservation += 1 * 0.01; // Second CPU: 1%
            }
            if (totalCpuCores >= 3) {
                let cores3to4 = Math.min(totalCpuCores - 2, 2);
                reservation += cores3to4 * 0.005; // 3rd-4th CPU: 0.5%
            }
            if (totalCpuCores > 4) {
                let remainingCores = totalCpuCores - 4;
                reservation += remainingCores * 0.0025; // Remaining: 0.25%
            }
            
            return reservation;
        }

        function calculateMemoryReservation(totalMemoryGB) {
            let reservation = 0;
            
            // 25% of first 4 GB
            let first4GB = Math.min(totalMemoryGB, 4);
            reservation += first4GB * 0.25;
            
            // 20% of next 4 GB (GB 4-8)
            if (totalMemoryGB > 4) {
                let next4GB = Math.min(totalMemoryGB - 4, 4);
                reservation += next4GB * 0.20;
            }
            
            // 10% of next 8 GB (GB 8-16)
            if (totalMemoryGB > 8) {
                let next8GB = Math.min(totalMemoryGB - 8, 8);
                reservation += next8GB * 0.10;
            }
            
            // 6% of next 112 GB (GB 16-128)
            if (totalMemoryGB > 16) {
                let next112GB = Math.min(totalMemoryGB - 16, 112);
                reservation += next112GB * 0.06;
            }
            
            // 2% of remaining memory (GB 128+)
            if (totalMemoryGB > 128) {
                let remaining = totalMemoryGB - 128;
                reservation += remaining * 0.02;
            }
            
            return reservation;
        }

        function calculateLogStorageRequirements() {
            const logVolumePerPod = parseFloat(document.getElementById('logVolumePerPod').value);
            const retentionDays = parseInt(document.getElementById('logRetentionDays').value);
            const compressionRatio = parseFloat(document.getElementById('compressionRatio').value);
            const replicationFactor = parseInt(document.getElementById('replicationFactor').value);

            // Calculate total pods across all workloads
            const totalPods = workloads.reduce((sum, workload) => sum + workload.instances, 0);
            
            // Calculate raw log volume
            const dailyRawLogVolume = totalPods * logVolumePerPod; // MB/day
            const totalRawLogVolume = dailyRawLogVolume * retentionDays; // MB total
            
            // Apply compression
            const compressedLogVolume = totalRawLogVolume / compressionRatio;
            
            // Add infrastructure logs (estimated at 20% of application logs)
            const infraLogVolume = compressedLogVolume * 0.2;
            const totalLogVolume = compressedLogVolume + infraLogVolume;
            
            // Apply replication factor (for Elasticsearch)
            let storageWithReplication = totalLogVolume;
            if (selectedLoggingStack === 'elasticsearch') {
                storageWithReplication = totalLogVolume * replicationFactor;
            }
            
            // Add safety margin (20%)
            const finalStorageRequirement = storageWithReplication * 1.2;
            
            // Convert to GB
            const storageRequirementGB = finalStorageRequirement / 1024;
            
            return {
                totalPods,
                dailyRawLogVolumeMB: dailyRawLogVolume,
                totalRawLogVolumeMB: totalRawLogVolume,
                compressedLogVolumeMB: compressedLogVolume,
                infraLogVolumeMB: infraLogVolume,
                totalLogVolumeMB: totalLogVolume,
                storageWithReplicationMB: storageWithReplication,
                finalStorageRequirementGB: storageRequirementGB,
                retentionDays,
                compressionRatio,
                replicationFactor
            };
        }

        function getMasterNodeRequirements() {
            // Master node resource requirements (per master)
            return {
                cpu: 2, // 2 vCPUs per master
                memory: 8 // 8 GB per master
            };
        }

        function getLoggingOverhead(stack, workerNodes) {
            if (stack === 'elasticsearch') {
                return {
                    memoryPerNode: 0.786, // 786Mi in GB
                    cpuPerNode: 0.25, // 250m in cores
                    totalMemory: workerNodes * 0.786,
                    totalCpu: workerNodes * 0.25
                };
            } else {
                return {
                    memoryPerNode: 2.05, // 2Gi + 50Mi in GB
                    cpuPerNode: 0.25, // 250m in cores
                    totalMemory: workerNodes * 2.05,
                    totalCpu: workerNodes * 0.25
                };
            }
        }

        function getInfrastructureRequirements(stack, clusterSize) {
            const loggingInfra = {
                elasticsearch: {
                    small: { memory: 49, cpu: 10, storage: 800 },
                    medium: { memory: 125, cpu: 15, storage: 2000 },
                    large: { memory: 280, cpu: 30, storage: 4000 }
                },
                loki: {
                    small: { memory: 16, cpu: 10, storage: 300 },
                    medium: { memory: 25, cpu: 18, storage: 600 },
                    large: { memory: 47, cpu: 35, storage: 1200 }
                }
            };

            const monitoring = {
                small: { memory: 10.6, cpu: 5, storage: 200 },
                medium: { memory: 25, cpu: 8, storage: 400 },
                large: { memory: 50, cpu: 15, storage: 800 }
            };

            const sizeCategory = getInfrastructureSizeCategory(stack, clusterSize);
            const logging = loggingInfra[stack][sizeCategory];
            const mon = monitoring[sizeCategory];
            return { totalMemory: logging.memory + mon.memory, totalCpu: logging.cpu + mon.cpu, totalStorage: logging.storage + mon.storage, loggingMemory: logging.memory, monitoringMemory: mon.memory };
        }

        function getInfrastructureSizeCategory(stack, clusterSize) {
            const loggingInfra = {
                elasticsearch: {
                    small: { memory: 49, cpu: 10, storage: 800 },
                    medium: { memory: 125, cpu: 15, storage: 2000 },
                    large: { memory: 280, cpu: 30, storage: 4000 }
                },
                loki: {
                    small: { memory: 16, cpu: 10, storage: 300 },
                    medium: { memory: 25, cpu: 18, storage: 600 },
                    large: { memory: 47, cpu: 35, storage: 1200 }
                }
            };

            const monitoring = {
                small: { memory: 10.6, cpu: 5, storage: 200 },
                medium: { memory: 25, cpu: 8, storage: 400 },
                large: { memory: 50, cpu: 15, storage: 800 }
            };

            let sizeCategory;
            if (clusterSize < 50) sizeCategory = 'small';
            else if (clusterSize < 250) sizeCategory = 'medium';
            else sizeCategory = 'large';

            return sizeCategory;
        }

        function calculateGrowthProjections(baseWorkloads, annualGrowthRate, months, usableVcpuPerNode, usableMemoryPerNode, maxUtilization, currentWorkerNodes) {
            const projections = [];
            const maxUtilizationPercent = maxUtilization * 100;

            // Derive total available resources per node for accurate utilization reporting
            const availableVcpuPerNode = usableVcpuPerNode / maxUtilization;
            const availableMemoryPerNode = usableMemoryPerNode / maxUtilization;
            
            // Convert annual growth rate to monthly growth rate
            const monthlyGrowthRate = Math.pow(1 + (annualGrowthRate / 100), 1/12) - 1;
            
            let firstUrgentMonth = null;
            let firstWarningMonth = null;
            let firstCautionMonth = null;

            let workerNodesForMonth = currentWorkerNodes; // Start with the initial node count
            
            for (let month = 0; month <= months; month++) {
                const growthFactor = month === 0 ? 1 : Math.pow(1 + monthlyGrowthRate, month);
                
                const projectedWorkloads = baseWorkloads.map(workload => ({
                    ...workload,
                    instances: Math.ceil(workload.instances * growthFactor)
                }));
                
                const totalInstances = projectedWorkloads.reduce((sum, w) => sum + w.instances, 0);
                const totalVcpu = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.vcpu), 0);
                const totalMemory = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.memory), 0);

                // Calculate utilization based on the nodes available at the start of the month
                const totalAvailableVcpu = workerNodesForMonth * availableVcpuPerNode;
                const totalAvailableMemory = workerNodesForMonth * availableMemoryPerNode;

                const cpuUtilization = (totalVcpu / totalAvailableVcpu) * 100;
                const memoryUtilization = (totalMemory / totalAvailableMemory) * 100;
                const maxCurrentUtilization = Math.max(cpuUtilization, memoryUtilization);
                
                // Determine if expansion is needed for the *next* month
                const needsExpansion = maxCurrentUtilization > maxUtilizationPercent;
                let optimalNodesForNextMonth = workerNodesForMonth;
                if (needsExpansion) {
                    const nodesForCpu = Math.ceil(totalVcpu / usableVcpuPerNode);
                    const nodesForMemory = Math.ceil(totalMemory / usableMemoryPerNode);
                    optimalNodesForNextMonth = Math.max(nodesForCpu, nodesForMemory, 3);
                }
                
                // Calculate growth from previous month
                let utilizationGrowth = 0;
                if (month > 0 && projections.length > 0) {
                    utilizationGrowth = maxCurrentUtilization - projections[projections.length - 1].maxUtilization;
                }
                
                // Recommendation logic - only set once for the first occurrence
                let recommendation = '';
                let showRecommendation = false;
                
                if (maxCurrentUtilization > maxUtilizationPercent + 5) {
                    recommendation = 'URGENT: Add nodes immediately';
                    if (firstUrgentMonth === null) {
                        firstUrgentMonth = month;
                        showRecommendation = true;
                    }
                } else if (maxCurrentUtilization > maxUtilizationPercent) {
                    recommendation = 'WARNING: Plan node expansion';
                    if (firstWarningMonth === null && firstUrgentMonth === null) {
                        firstWarningMonth = month;
                        showRecommendation = true;
                    }
                } else if (maxCurrentUtilization > maxUtilizationPercent - 10) {
                    recommendation = 'CAUTION: Monitor closely';
                    if (firstCautionMonth === null && firstWarningMonth === null && firstUrgentMonth === null) {
                        firstCautionMonth = month;
                        showRecommendation = true;
                    }
                } else {
                    recommendation = 'OK: Capacity sufficient';
                }
                
                projections.push({
                    month: month,
                    workloads: projectedWorkloads,
                    totalInstances: totalInstances,
                    totalVcpu: totalVcpu,
                    totalMemory: totalMemory,
                    workerNodesInMonth: workerNodesForMonth,
                    recommendedNodesForNextMonth: optimalNodesForNextMonth,
                    cpuUtilization: cpuUtilization,
                    memoryUtilization: memoryUtilization,
                    maxUtilization: maxCurrentUtilization,
                    utilizationGrowth: utilizationGrowth,
                    needsExpansion: needsExpansion,
                    recommendation: recommendation,
                    showRecommendation: showRecommendation,
                    growthFactor: growthFactor,
                    monthlyGrowthRate: monthlyGrowthRate * 100
                });

                // Set the node count for the next iteration
                workerNodesForMonth = optimalNodesForNextMonth;
            }
            
            return projections;
        }

        function exportToExcel() {
            if (!window.lastCalculationResults) {
                alert('Please calculate resources first before exporting');
                return;
            }

            const calc = window.lastCalculationResults;
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Summary sheet
            const summaryData = [
                ['OpenShift Resource Planning Calculator'],
                ['Generated on:', new Date().toLocaleString()],
                [''],
                ['Cluster Summary'],
                ['Worker Nodes Required:', calc.finalWorkerNodes],
                ['Master Nodes:', calc.mergeMasters ? '0 (merged)' : calc.masterNodes],
                ['Dedicated Infrastructure:', calc.infraReqs.totalCpu > 0 ? 'User-defined resource pool' : 'None'],
                ['Total Cluster Size:', calc.totalClusterNodes],
                ['Configuration:', calc.mergeMasters ? 'Compact cluster (Masters merged)' : 'Dedicated nodes'],
                [''],
                ['Workload Requirements'],
                ['Total Application Instances:', calc.totalInstances],
                ['Total vCPU Needed:', calc.totalVcpuNeeded.toFixed(1)],
                ['Total Memory Needed (GB):', calc.totalMemoryNeeded.toFixed(1)],
                ['Logging Stack:', calc.selectedLoggingStack === 'elasticsearch' ? 'Elasticsearch' : 'LokiStack'],
                [''],
                ['Worker Node Capacity'],
                ['Physical CPU Cores:', calc.cpuCores],
                ['Total vCPUs per Node:', calc.totalVcpuPerNode],
                ['Available vCPUs (after OS):', calc.availableVcpuPerNode.toFixed(2)],
                ['Available Memory (after OS) (GB):', calc.availableMemoryPerNode.toFixed(1)],
                [''],
                ['Utilization Analysis'],
                ['CPU Utilization (%):', calc.actualCpuUtilization.toFixed(1)],
                ['Memory Utilization (%):', calc.actualMemoryUtilization.toFixed(1)],
                ['Max Utilization Target (%):', calc.maxUtilization],
                [''],
                ['Subscription Requirements'],
                ['Model:', calc.subscriptionInfo.type],
                ['Billable Nodes (Workers):', calc.finalWorkerNodes],
                ['Total Billable Cores:', calc.subscriptionInfo.totalPhysicalCores],
                ...(calc.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? 
                    [['Total Billable Sockets:', calc.subscriptionInfo.totalSockets]] : 
                    []),
                ['Required Subscriptions:', calc.subscriptionInfo.count],
                ['Calculation:', calc.subscriptionInfo.calculationMethod],
                [''],
                ['Calculated Infrastructure Requirements'],
                ['Total Infra CPU (Cores):', calc.infraReqs.totalCpu.toFixed(1)],
                ['Total Infra Memory (GB):', calc.infraReqs.totalMemory.toFixed(1)],
                ['Total Infra Storage (GB):', calc.infraReqs.totalStorage.toFixed(1)],
                [''],
                ['Log Storage Requirements'],
                ['Total Pods Generating Logs:', calc.logStorage.totalPods],
                ['Daily Raw Log Volume (GB):', (calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)],
                ['Total Storage Required (GB):', calc.logStorage.finalStorageRequirementGB.toFixed(1)],
                ['Retention Period (days):', calc.logStorage.retentionDays],
                ['Compression Ratio:', calc.logStorage.compressionRatio + ':1']
            ];
            
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
            
            // Workloads sheet
            const workloadData = [
                ['Workload Breakdown'],
                ['Name', 'Instances', 'vCPU per Instance', 'Memory per Instance (GB)', 'Total vCPU', 'Total Memory (GB)']
            ];
            
            calc.workloads.forEach(workload => {
                workloadData.push([
                    workload.name,
                    workload.instances,
                    workload.vcpu,
                    workload.memory,
                    (workload.instances * workload.vcpu).toFixed(1),
                    (workload.instances * workload.memory).toFixed(1)
                ]);
            });
            
            const workloadWs = XLSX.utils.aoa_to_sheet(workloadData);
            XLSX.utils.book_append_sheet(wb, workloadWs, 'Workloads');
            
            // Growth projections sheet (if available)
            if (calc.growthProjections) {
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
                
                const growthData = [
                    ['Growth Projections'],
                    ['Annual Growth Rate (%):', annualGrowthRate],
                    ['Equivalent Monthly Growth Rate (%):', monthlyGrowthRate.toFixed(3)],
                    [''],
                    ['Month', 'Total Instances', 'Total vCPU', 'Total Memory (GB)', 'Nodes in Month', 'CPU Utilization (%)', 'Memory Utilization (%)', 'Max Utilization (%)', 'Utilization Growth (%)', 'Recommendation', 'Show Alert']
                ];
                
                calc.growthProjections.forEach(proj => {
                    growthData.push([
                        proj.month,
                        proj.totalInstances,
                        proj.totalVcpu.toFixed(1),
                        proj.totalMemory.toFixed(1),
                        proj.workerNodesInMonth,
                        proj.cpuUtilization.toFixed(1),
                        proj.memoryUtilization.toFixed(1),
                        proj.maxUtilization.toFixed(1),
                        proj.utilizationGrowth.toFixed(1),
                        proj.recommendation,
                        proj.showRecommendation ? 'YES' : 'NO'
                    ]);
                });
                
                const growthWs = XLSX.utils.aoa_to_sheet(growthData);
                XLSX.utils.book_append_sheet(wb, growthWs, 'Growth Projections');
            }
            
            // Save file
            const fileName = `OpenShift_Resource_Plan_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function createGrowthChart(projections, maxUtilizationThreshold) {
            const canvas = document.getElementById('growthChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.growthChartInstance) {
                window.growthChartInstance.destroy();
            }
            
            // Create threshold line data
            const thresholdData = projections.map(() => maxUtilizationThreshold);
            const warningThresholdData = projections.map(() => maxUtilizationThreshold + 10);
            
            window.growthChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: projections.map(p => `Month ${p.month}`),
                    datasets: [
                        {
                            label: 'Cluster Utilization (%)',
                            data: projections.map(p => p.maxUtilization),
                            borderColor: '#ee0979',
                            backgroundColor: 'rgba(238, 9, 121, 0.1)',
                            tension: 0.4,
                            fill: false,
                            pointRadius: 5,
                            pointHoverRadius: 8
                        },
                        {
                            label: 'Target Threshold',
                            data: thresholdData,
                            borderColor: '#28a745',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            tension: 0,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        },
                        {
                            label: 'Warning Threshold',
                            data: warningThresholdData,
                            borderColor: '#ffc107',
                            backgroundColor: 'transparent',
                            borderDash: [10, 5],
                            tension: 0,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Timeline'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Utilization (%)'
                            },
                            min: 0,
                            max: Math.max(100, Math.max(...projections.map(p => p.maxUtilization)) + 10)
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Growth Projection: Cluster Utilization Over Time'
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    if (context[0].datasetIndex === 0) {
                                        const projection = projections[context[0].dataIndex];
                                        return [
                                            `Instances: ${projection.totalInstances}`,
                                            `vCPU Usage: ${projection.totalVcpu.toFixed(1)}`,
                                            `Memory Usage: ${projection.totalMemory.toFixed(1)} GB`,
                                            `Recommendation: ${projection.recommendation}`
                                        ];
                                    }
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
        }

        function calculateResources() {
            // Update workloads from UI
            updateWorkloads();
            
            if (workloads.length === 0) {
                alert('Please add at least one workload type');
                return;
            }

            // Calculate total workload requirements
            const totalInstances = workloads.reduce((sum, workload) => sum + workload.instances, 0);
            const totalVcpuNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.vcpu), 0);
            const totalMemoryNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.memory), 0);

            // Calculate log storage requirements
            const logStorage = calculateLogStorageRequirements();

            // Get worker node specifications
            const cpuCores = parseInt(document.getElementById('cpuCores').value);
            const cpuToVcpuRatio = parseFloat(document.getElementById('cpuToVcpuRatio').value);
            const socketsPerNode = parseInt(document.getElementById('socketsPerNode').value);
            const memoryPerNode = parseInt(document.getElementById('memoryPerNode').value);
            const maxUtilization = parseInt(document.getElementById('maxUtilization').value) / 100;
            
            // Get merge options
            const mergeMasters = document.getElementById('mergeMasters').checked;
            
            // Calculate worker node capacity
            const totalVcpuPerNode = cpuCores * cpuToVcpuRatio;
            
            // Calculate OpenShift reservations
            const cpuReservation = calculateCpuReservation(cpuCores);
            const memoryReservation = calculateMemoryReservation(memoryPerNode);
            
            // Available resources after OpenShift reservations
            let availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
            let availableMemoryPerNode = memoryPerNode - memoryReservation;
            
            // Account for master node requirements if merged
            let masterOverhead = { cpu: 0, memory: 0 };
            if (mergeMasters) {
                const masterReqs = getMasterNodeRequirements();
                masterOverhead.cpu = masterReqs.cpu;
                masterOverhead.memory = masterReqs.memory;
                availableVcpuPerNode -= masterReqs.cpu;
                availableMemoryPerNode -= masterReqs.memory;
            }
            
            // Calculate usable resources considering max utilization
            const usableVcpuPerNode = availableVcpuPerNode * maxUtilization;
            const usableMemoryPerNode = availableMemoryPerNode * maxUtilization;
            
            // Calculate worker nodes needed (before logging overhead)
            const nodesForCpu = Math.ceil(totalVcpuNeeded / usableVcpuPerNode);
            const nodesForMemory = Math.ceil(totalMemoryNeeded / usableMemoryPerNode);
            let baseWorkerNodes = Math.max(nodesForCpu, nodesForMemory);
            
            // For merged masters, ensure minimum 3 nodes for HA
            if (mergeMasters) {
                baseWorkerNodes = Math.max(baseWorkerNodes, 3);
            }
            
            // Account for logging overhead and recalculate
            let finalWorkerNodes = baseWorkerNodes;
            let iterations = 0;
            const maxIterations = 10;
            let infraReqs = {};
            
            while (iterations < maxIterations) {
                const loggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
                
                // Calculate infra requirements based on current estimated cluster size
                const currentClusterSize = (mergeMasters ? 0 : 3) + finalWorkerNodes;
                infraReqs = getInfrastructureRequirements(selectedLoggingStack, currentClusterSize);
                
                // Total requirements including logging and infra overhead
                let totalVcpuWithLogging = totalVcpuNeeded + loggingOverhead.totalCpu + infraReqs.totalCpu;
                let totalMemoryWithLogging = totalMemoryNeeded + loggingOverhead.totalMemory + infraReqs.totalMemory;
                
                // Calculate new worker node requirements
                const newNodesForCpu = Math.ceil(totalVcpuWithLogging / usableVcpuPerNode);
                const newNodesForMemory = Math.ceil(totalMemoryWithLogging / usableMemoryPerNode);
                let newWorkerNodes = Math.max(newNodesForCpu, newNodesForMemory);
                
                // Ensure minimum nodes for merged configurations
                if (mergeMasters) {
                    newWorkerNodes = Math.max(newWorkerNodes, 3);
                }
                
                if (newWorkerNodes === finalWorkerNodes) {
                    break; // Converged
                }
                
                finalWorkerNodes = newWorkerNodes;
                iterations++;
            }

            // Calculate final cluster size
            const masterNodes = mergeMasters ? 0 : 3;
            // Infra nodes are now explicitly defined by user input, not calculated as part of the primary cluster node count.
            // The 'infraNodes' variable here will represent the count of *dedicated* infra nodes if the user specifies them,
            // but for the purpose of 'totalClusterNodes' (which influences logging/monitoring sizing), we only count masters and workers.
            const totalClusterNodes = masterNodes + finalWorkerNodes;
            
            // Calculate subscription requirements based on worker nodes only
            const subscriptionInfo = calculateSubscriptions(selectedSubscriptionType, finalWorkerNodes, cpuCores, socketsPerNode);

            // Recalculate final infra requirements based on the converged node count
            const finalInfraReqs = getInfrastructureRequirements(selectedLoggingStack, totalClusterNodes);

            // Note: getLoggingOverhead already uses workerNodes, not totalClusterNodes for per-node overhead
            const finalLoggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
            
            // Calculate final overhead
            const finalInfraOverhead = { cpu: finalInfraReqs.totalCpu, memory: finalInfraReqs.totalMemory };
            // Calculate actual utilization
            let totalVcpuWithLogging = totalVcpuNeeded + finalLoggingOverhead.totalCpu + finalInfraOverhead.cpu;
            let totalMemoryWithLogging = totalMemoryNeeded + finalLoggingOverhead.totalMemory + finalInfraOverhead.memory;
            
            const actualCpuUtilization = (totalVcpuWithLogging / (finalWorkerNodes * availableVcpuPerNode)) * 100;
            const actualMemoryUtilization = (totalMemoryWithLogging / (finalWorkerNodes * availableMemoryPerNode)) * 100;

            // Growth projections
            let growthProjections = null;
            if (document.getElementById('enableGrowth').checked) {
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const projectionMonths = parseInt(document.getElementById('projectionMonths').value);
                
                growthProjections = calculateGrowthProjections(
                    workloads, 
                    annualGrowthRate, 
                    projectionMonths, 
                    usableVcpuPerNode, 
                    usableMemoryPerNode, 
                    maxUtilization,
                    finalWorkerNodes
                );
            }

            // Store results for export
            window.lastCalculationResults = {
                workloads,
                totalInstances,
                totalVcpuNeeded,
                totalMemoryNeeded,
                logStorage,
                cpuCores,
                cpuToVcpuRatio,
                socketsPerNode,
                totalVcpuPerNode,
                memoryPerNode,
                cpuReservation,
                memoryReservation,
                availableVcpuPerNode: availableVcpuPerNode + (mergeMasters ? masterOverhead.cpu : 0),
                availableMemoryPerNode: availableMemoryPerNode + (mergeMasters ? masterOverhead.memory : 0),
                usableVcpuPerNode,
                usableMemoryPerNode,
                finalWorkerNodes,
                masterNodes,
                infraNodes: 0, // Dedicated infra nodes are now a resource pool, not counted in this 'nodes' variable
                totalClusterNodes, // This is the final converged infra requirements
                infraReqs: finalInfraReqs,
                finalLoggingOverhead,
                actualCpuUtilization,
                actualMemoryUtilization,
                maxUtilization: maxUtilization * 100,
                totalVcpuWithLogging,
                totalMemoryWithLogging,
                mergeMasters,
                masterOverhead,
                finalInfraOverhead, // This is now correctly defined and passed
                growthProjections,
                subscriptionInfo
            };

            // Display results
            displayResults(window.lastCalculationResults);
        }

        function displayResults(calc) {
            const resultsContainer = document.getElementById('results-container');
            
            const isOverutilized = calc.actualCpuUtilization > calc.maxUtilization || calc.actualMemoryUtilization > calc.maxUtilization;
            const utilizationStatusMessage = isOverutilized ? 
                '<div class="warning">⚠️ Warning: Resource utilization exceeds target. Consider adding more nodes or using larger ones.</div>' : 
                '<div class="success">✅ Allocation looks good! All utilization targets are met.</div>';

            let resultsHTML = `
                <div class="result-card" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">
                    <h3>🔑 Key Recommendations</h3>
                    <div class="result-item">
                        <span><span class="status-icon">#️⃣</span>Worker Nodes Required:</span>
                        <span class="result-value" style="font-size: 1.5rem;">${calc.finalWorkerNodes}</span>
                    </div>
                     <div class="result-item">
                        <span><span class="status-icon">🎟️</span>Required Subscriptions:</span>
                        <span class="result-value" style="font-size: 1.5rem;">${calc.subscriptionInfo.count}</span>
                    </div>
                    <div class="result-item">
                        <span><span class="status-icon">${isOverutilized ? '⚠️' : '✅'}</span>Cluster Utilization:</span>
                        <span class="result-value">CPU: ${calc.actualCpuUtilization.toFixed(1)}% | Mem: ${calc.actualMemoryUtilization.toFixed(1)}%</span>
                    </div>
                    ${utilizationStatusMessage}
                </div>

                <div class="result-card">
                    <h3>🏗️ Cluster Profile & Node Configuration</h3>
                    <div class="result-item"><span>Total Worker Nodes:</span><span class="result-value">${calc.finalWorkerNodes}</span></div>
                    <div class="result-item"><span>Total Master Nodes:</span><span class="result-value">${calc.mergeMasters ? '0 (merged)' : calc.masterNodes}</span></div>
                    <div class="result-item"><span>Configuration:</span><span class="result-value">${calc.mergeMasters ? 'Compact' : 'Dedicated Masters'}</span></div>
                    
                    <div class="breakdown-section" style="margin-top: 20px; background: rgba(255,255,255,0.1);">
                        <div class="breakdown-title" style="color: white;">Single Worker Node Profile</div>
                        <div class="breakdown-item"><span>Physical Capacity</span><span>${calc.cpuCores} Cores / ${calc.memoryPerNode} GB RAM</span></div>
                        <div class="breakdown-item"><span>(-) OS/System Reservation</span><span>-${calc.cpuReservation.toFixed(2)} Cores / -${calc.memoryReservation.toFixed(1)} GB RAM</span></div>
                        ${calc.mergeMasters ? `<div class="breakdown-item"><span>(-) Master Services Overhead</span><span>-${calc.masterOverhead.cpu} vCPUs / -${calc.masterOverhead.memory} GB RAM</span></div>` : ''}
                        <div class="breakdown-item"><span>(-) Logging Agent Overhead</span><span>-${calc.finalLoggingOverhead.cpuPerNode.toFixed(2)} vCPUs / -${calc.finalLoggingOverhead.memoryPerNode.toFixed(2)} GB RAM</span></div>
                        <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold;"><span>(=) Available for Workloads</span><span>${(calc.availableVcpuPerNode + (calc.mergeMasters ? calc.masterOverhead.cpu : 0)).toFixed(2)} vCPUs / ${(calc.availableMemoryPerNode + (calc.mergeMasters ? calc.masterOverhead.memory : 0)).toFixed(1)} GB RAM</span></div>
                        <div class="breakdown-item"><span>(×) Max Utilization Target</span><span>${calc.maxUtilization}%</span></div>
                        <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold; background: rgba(0,0,0,0.2);"><span>(=) Usable Capacity per Node</span><span>${calc.usableVcpuPerNode.toFixed(2)} vCPUs / ${calc.usableMemoryPerNode.toFixed(1)} GB RAM</span></div>
                    </div>
                </div>

                <div class="result-card">
                    <h3>💻 Total Resource Demand</h3>
                    <div class="breakdown-section" style="background: rgba(255,255,255,0.1);">
                        <div class="breakdown-title" style="color: white;">Application Workloads</div>
                        ${calc.workloads.map(w => `
                            <div class="breakdown-item">
                                <span>${w.name} (${w.instances} x ${w.type})</span>
                                <span>${(w.instances * w.vcpu).toFixed(1)} vCPUs / ${(w.instances * w.memory).toFixed(1)} GB</span>
                            </div>
                        `).join('')}
                        <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold;">
                            <span>Subtotal:</span>
                            <span>${calc.totalVcpuNeeded.toFixed(1)} vCPUs / ${calc.totalMemoryNeeded.toFixed(1)} GB</span>
                        </div>
                    </div>
                    <div class="breakdown-section" style="margin-top: 15px; background: rgba(255,255,255,0.1);">
                        <div class="breakdown-title" style="color: white;">Cluster Services Overhead</div>
                        <div class="breakdown-item"><span>Logging, Monitoring, etc.</span><span>${calc.finalInfraOverhead.cpu.toFixed(1)} vCPUs / ${calc.finalInfraOverhead.memory.toFixed(1)} GB</span></div>
                    </div>
                     <div class="result-item" style="margin-top: 15px;">
                        <span><strong>Total Required Capacity:</strong></span>
                        <span class="result-value">${calc.totalVcpuWithLogging.toFixed(1)} vCPUs / ${calc.totalMemoryWithLogging.toFixed(1)} GB</span>
                    </div>
                </div>

                <div class="result-card">
                    <h3>🎟️ OpenShift Subscription Estimate</h3>
                    <div class="result-item">
                        <span>Subscription Model:</span>
                        <span class="result-value">${calc.subscriptionInfo.type}</span>
                    </div>
                    <div class="result-item">
                        <span>Total Billable Physical Cores (on ${calc.finalWorkerNodes} worker nodes):</span>
                        <span class="result-value">${calc.subscriptionInfo.totalPhysicalCores} cores</span>
                    </div>
                    ${calc.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
                    <div class="result-item">
                        <span>Total Billable Sockets (on ${calc.finalWorkerNodes} worker nodes):</span>
                        <span class="result-value">${calc.subscriptionInfo.totalSockets} sockets</span>
                    </div>
                    ` : ''}
                    <div class="result-item">
                        <span><strong>Required Subscriptions:</strong></span>
                        <span class="result-value" style="font-size: 1.5rem;">${calc.subscriptionInfo.count}</span>
                    </div>
                    <div class="warning" style="margin-top: 15px; padding: 10px; text-align: center; background: rgba(0,0,0,0.2);">
                        💡 <strong>Calculation:</strong> ${calc.subscriptionInfo.calculationMethod}
                    </div>
                </div>`;

            resultsHTML += `
                <div class="storage-breakdown">
                    <h3>💾 Log Storage Requirements</h3>
                    <div class="result-item">
                        <span>Total Pods Generating Logs:</span>
                        <span class="result-value">${calc.logStorage.totalPods}</span>
                    </div>
                    <div class="result-item">
                        <span>Daily Raw Log Volume:</span>
                        <span class="result-value">${(calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)} GB/day</span>
                    </div>
                    <div class="result-item">
                        <span>Total Storage Required (incl. retention, compression):</span>
                        <span class="result-value">${calc.logStorage.finalStorageRequirementGB.toFixed(1)} GB</span>
                    </div>
                    ${selectedLoggingStack === 'elasticsearch' ? `
                    <div class="result-item">
                        <span>Replication Factor:</span>
                        <span class="result-value">${calc.logStorage.replicationFactor}x</span>
                    </div>
                    ` : ''}
                </div>
            `;


            // Growth projections
            if (calc.growthProjections) {
                const currentUtilization = Math.max(calc.actualCpuUtilization, calc.actualMemoryUtilization);
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
                
                resultsHTML += `
                    <div class="growth-chart-container">
                        <h3>📈 Growth Projections</h3>
                        <div class="result-item" style="margin-bottom: 15px;">
                            <span>Current Cluster Utilization:</span>
                            <span class="result-value">${currentUtilization.toFixed(1)}%</span>
                        </div>
                        <div class="result-item" style="margin-bottom: 15px;">
                            <span>Annual Growth Rate:</span>
                            <span class="result-value">${annualGrowthRate}% (${monthlyGrowthRate.toFixed(2)}% monthly)</span>
                        </div>
                        <canvas id="growthChart" width="400" height="200"></canvas>
                    </div>
                    
                    <div class="growth-projections">
                        <div class="projection-card">
                            <h4>🚀 Monthly Growth Analysis</h4>
                `;
                
                // Show key months
                const keyMonths = calc.growthProjections.filter((_, index) => 
                    index === 0 || index === 3 || index === 6 || index === 12 || index === calc.growthProjections.length - 1
                ).slice(0, 6);
                
                keyMonths.forEach(proj => {
                    resultsHTML += `
                        <div class="projection-item">
                            <span>Month ${proj.month}: ${proj.maxUtilization.toFixed(1)}%</span>
                            <span>${proj.utilizationGrowth > 0 ? '+' : ''}${proj.utilizationGrowth.toFixed(1)}% growth</span>
                        </div>
                    `;
                });
                
                const totalGrowth = ((calc.growthProjections[calc.growthProjections.length - 1].totalInstances / calc.totalInstances - 1) * 100).toFixed(1);
                const finalUtilization = calc.growthProjections[calc.growthProjections.length - 1].maxUtilization;
                
                resultsHTML += `
                        </div>
                        
                        <div class="projection-card">
                            <h4>📊 Growth Summary</h4>
                            <div class="projection-item">
                                <span>Total Instance Growth:</span>
                                <span class="result-value">${totalGrowth}%</span>
                            </div>
                            <div class="projection-item">
                                <span>Final Utilization:</span>
                                <span class="result-value">${finalUtilization.toFixed(1)}%</span>
                            </div>
                            <div class="projection-item">
                                <span>Utilization Increase:</span>
                                <span>+${(finalUtilization - currentUtilization).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;

                // Recommendations section - only show the first critical recommendation
                const firstCriticalRecommendation = calc.growthProjections.find(proj => 
                    proj.showRecommendation && (proj.recommendation.includes('URGENT') || proj.recommendation.includes('WARNING') || proj.recommendation.includes('CAUTION'))
                );

                resultsHTML += `
                    <div class="recommendation-card">
                        <h4>🎯 Node Expansion Recommendation</h4>
                `;

                if (firstCriticalRecommendation) {
                    let statusClass = '';
                    if (firstCriticalRecommendation.recommendation.includes('URGENT')) statusClass = 'status-urgent';
                    else if (firstCriticalRecommendation.recommendation.includes('WARNING')) statusClass = 'status-warning';
                    else if (firstCriticalRecommendation.recommendation.includes('CAUTION')) statusClass = 'status-caution';
                    else statusClass = 'status-ok';

                    const nodesNeeded = firstCriticalRecommendation.recommendedNodesForNextMonth - firstCriticalRecommendation.workerNodesInMonth;

                    resultsHTML += `
                        <div class="recommendation-item">
                            <span>Month ${firstCriticalRecommendation.month}: ${firstCriticalRecommendation.maxUtilization.toFixed(1)}% utilization</span>
                            <span class="recommendation-status ${statusClass}">${firstCriticalRecommendation.recommendation}</span>
                        </div>`;
                    if (nodesNeeded > 0) {
                        resultsHTML += `<div class="recommendation-item">
                                <span>Recommended Action:</span>
                                <span class="result-value">Add ${nodesNeeded} worker node(s)</span>
                            </div>`;
                    }
                    resultsHTML += `
                        <div class="recommendation-item">
                            <span>Target Instances at that time:</span>
                            <span class="result-value">${firstCriticalRecommendation.totalInstances} instances</span>
                        </div>
                    `;
                } else {
                    resultsHTML += `
                        <div class="recommendation-item">
                            <span>No capacity expansion needed within projection period</span>
                            <span class="recommendation-status status-ok">OK: Current capacity sufficient</span>
                        </div>
                    `;
                }

                resultsHTML += '</div>';
            }

            resultsContainer.innerHTML = resultsHTML;

            // Create growth chart if projections exist
            if (calc.growthProjections) {
                setTimeout(() => {
                    createGrowthChart(calc.growthProjections, calc.maxUtilization);
                }, 100);
            }

            // Show export button
            document.getElementById('exportBtn').style.display = 'inline-flex';
        }

        function saveInputsToLocalStorage() {
            // Collect all sizing inputs
            const sizingInputs = {
                workloads: workloads, // 'workloads' global variable is already up-to-date
                cpuCores: document.getElementById('cpuCores').value,
                customizeSockets: document.getElementById('customizeSockets').checked,
                socketsPerNode: document.getElementById('socketsPerNode').value,
                cpuToVcpuRatio: document.getElementById('cpuToVcpuRatio').value,
                memoryPerNode: document.getElementById('memoryPerNode').value,
                maxUtilization: document.getElementById('maxUtilization').value,
                mergeMasters: document.getElementById('mergeMasters').checked,
                loggingStack: selectedLoggingStack,
                subscriptionType: selectedSubscriptionType,
                logVolumePerPod: document.getElementById('logVolumePerPod').value,
                logRetentionDays: document.getElementById('logRetentionDays').value,
                compressionRatio: document.getElementById('compressionRatio').value,
                replicationFactor: document.getElementById('replicationFactor').value,
                enableGrowth: document.getElementById('enableGrowth').checked,
                growthRate: document.getElementById('growthRate').value,
                projectionMonths: document.getElementById('projectionMonths').value,
            };

            // Collect all capacity inputs
            const capacityInputs = {
                capacityWorkerNodes: document.getElementById('capacityWorkerNodes').value,
                capacityCpuCores: document.getElementById('capacityCpuCores').value,
                capacityMemoryPerNode: document.getElementById('capacityMemoryPerNode').value,
                capacityCustomizeSockets: document.getElementById('capacityCustomizeSockets').checked,
                capacitySocketsPerNode: document.getElementById('capacitySocketsPerNode').value,
                // The subscription type is shared, but let's read it from its own context
                capacitySubscriptionType: document.querySelector('input[name="capacitySubscriptionType"]:checked').value,
            };

            const dataToSave = {
                mode: currentMode,
                sizing: sizingInputs,
                capacity: capacityInputs
            };

            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
        }

        function loadInputsFromLocalStorage() {
            const savedDataJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!savedDataJSON) {
                initializeWorkloads(); // If no saved data, just start with a default workload
                return;
            }

            try {
                const savedData = JSON.parse(savedDataJSON);

                // Restore mode
                const modeSelector = document.getElementById('mode-selector');
                const modeOption = modeSelector.querySelector(`div[onclick*="'${savedData.mode}'"]`);
                if (modeOption) {
                    switchMode(savedData.mode, modeOption);
                }

                // Restore Sizing Inputs
                const sizing = savedData.sizing;
                if (sizing) {
                    document.getElementById('cpuCores').value = sizing.cpuCores;
                    document.getElementById('customizeSockets').checked = sizing.customizeSockets;
                    document.getElementById('socketsPerNode').value = sizing.socketsPerNode;
                    toggleSocketInput(); // Update visibility
                    document.getElementById('cpuToVcpuRatio').value = sizing.cpuToVcpuRatio;
                    document.getElementById('memoryPerNode').value = sizing.memoryPerNode;
                    document.getElementById('maxUtilization').value = sizing.maxUtilization;
                    document.getElementById('mergeMasters').checked = sizing.mergeMasters;

                    const logStackOption = document.querySelector(`div[onclick*="'${sizing.loggingStack}'"]`);
                    if (logStackOption) selectLoggingStack(sizing.loggingStack, logStackOption);

                    const subTypeOption = document.querySelector(`#subscription-type-selector div[onclick*="'${sizing.subscriptionType}'"]`);
                    if (subTypeOption) selectSubscriptionType(sizing.subscriptionType, subTypeOption);

                    document.getElementById('logVolumePerPod').value = sizing.logVolumePerPod;
                    document.getElementById('logRetentionDays').value = sizing.logRetentionDays;
                    document.getElementById('compressionRatio').value = sizing.compressionRatio;
                    document.getElementById('replicationFactor').value = sizing.replicationFactor;

                    document.getElementById('enableGrowth').checked = sizing.enableGrowth;
                    toggleGrowthInputs(); // Update visibility
                    document.getElementById('growthRate').value = sizing.growthRate;
                    document.getElementById('projectionMonths').value = sizing.projectionMonths;

                    // Restore workloads
                    document.getElementById('workloads-container').innerHTML = '';
                    workloadCounter = 0;
                    workloads = [];
                    if (sizing.workloads && sizing.workloads.length > 0) {
                        sizing.workloads.forEach(workload => {
                            addWorkload(workload);
                        });
                        updateWorkloads(); // This will update the global 'workloads' array and check for VM subscription requirements
                    } else {
                        addWorkload(); // Add a default one if none were saved
                    }
                }

                // Restore Capacity Inputs
                const capacity = savedData.capacity;
                if (capacity) {
                    document.getElementById('capacityWorkerNodes').value = capacity.capacityWorkerNodes;
                    document.getElementById('capacityCpuCores').value = capacity.capacityCpuCores;
                    document.getElementById('capacityMemoryPerNode').value = capacity.capacityMemoryPerNode;
                    document.getElementById('capacityCustomizeSockets').checked = capacity.capacityCustomizeSockets;
                    document.getElementById('capacitySocketsPerNode').value = capacity.capacitySocketsPerNode;
                    toggleCapacitySocketInput(); // Update visibility

                    const capSubTypeOption = document.querySelector(`#capacity-subscription-type-selector div[onclick*="'${capacity.capacitySubscriptionType}'"]`);
                    if (capSubTypeOption) selectSubscriptionType(capacity.capacitySubscriptionType, capSubTypeOption);
                }
            } catch (e) {
                console.error("Failed to load saved data, resetting to defaults.", e);
                localStorage.removeItem(LOCAL_STORAGE_KEY);
                initializeWorkloads();
            }
        }

        function switchMode(mode, element) {
            currentMode = mode;
            
            document.getElementById('sizing-calculator-inputs').style.display = (mode === 'sizing') ? 'block' : 'none';
            document.getElementById('capacity-estimator-inputs').style.display = (mode === 'capacity') ? 'block' : 'none';

            // Update UI selection
            element.parentElement.querySelectorAll('.radio-option').forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
            element.querySelector('input[type="radio"]').checked = true;

            // Clear results
            document.getElementById('results-container').innerHTML = `
                <div class="result-card">
                    <h3>👋 Welcome!</h3>
                    <p>Configure your options and click the button to see the results.</p>
                </div>
            `;
            document.getElementById('exportBtn').style.display = 'none';
            saveInputsToLocalStorage();
        }

        function resetToDefaults() {
            if (!confirm('Are you sure you want to reset all inputs to their default values? This will clear any saved data.')) {
                return;
            }

            // Clear local storage
            localStorage.removeItem(LOCAL_STORAGE_KEY);

            // Reset Sizing Inputs
            document.getElementById('cpuCores').value = 8;
            document.getElementById('customizeSockets').checked = false;
            document.getElementById('socketsPerNode').value = 2;
            toggleSocketInput();
            document.getElementById('cpuToVcpuRatio').value = 2;
            document.getElementById('memoryPerNode').value = 32;
            document.getElementById('maxUtilization').value = 80;
            document.getElementById('mergeMasters').checked = false;

            selectLoggingStack('elasticsearch', document.querySelector('div[onclick*="\'elasticsearch\'"]'));
            selectSubscriptionType('core', document.querySelector('#subscription-type-selector div[onclick*="\'core\'"]'));

            document.getElementById('logVolumePerPod').value = 100;
            document.getElementById('logRetentionDays').value = 30;
            document.getElementById('compressionRatio').value = 3;
            document.getElementById('replicationFactor').value = 1;

            document.getElementById('enableGrowth').checked = false;
            toggleGrowthInputs();
            document.getElementById('growthRate').value = 50;
            document.getElementById('projectionMonths').value = 12;

            // Reset workloads
            document.getElementById('workloads-container').innerHTML = '';
            workloadCounter = 0;
            workloads = [];
            addWorkload();

            // Reset Capacity Inputs
            document.getElementById('capacityWorkerNodes').value = 3;
            document.getElementById('capacityCpuCores').value = 8;
            document.getElementById('capacityMemoryPerNode').value = 32;
            document.getElementById('capacityCustomizeSockets').checked = false;
            document.getElementById('capacitySocketsPerNode').value = 2;
            toggleCapacitySocketInput();
            selectSubscriptionType('core', document.querySelector('#capacity-subscription-type-selector div[onclick*="\'core\'"]'));

            // Reset results
            document.getElementById('results-container').innerHTML = `
                <div class="result-card">
                    <h3>👋 Welcome!</h3>
                    <p>Inputs have been reset to default values.</p>
                </div>
            `;
            document.getElementById('exportBtn').style.display = 'none';

            alert('All inputs have been reset to their default values.');
        }
        
        function calculateCapacity() {
            // Get custom infrastructure values from inputs
            const infra = {
                workers: parseInt(document.getElementById('capacityWorkerNodes').value) || 0,
                cpu: parseInt(document.getElementById('capacityCpuCores').value) || 0,
                memory: parseInt(document.getElementById('capacityMemoryPerNode').value) || 0
            };

            if (infra.workers <= 0 || infra.cpu <= 0 || infra.memory <= 0) {
                alert('Please enter valid, positive numbers for infrastructure specifications.');
                return;
            }

            // Get subscription inputs
            const socketsPerNode = parseInt(document.getElementById('capacitySocketsPerNode').value) || 2;
            const subscriptionInfo = calculateSubscriptions(selectedSubscriptionType, infra.workers, infra.cpu, socketsPerNode);

            const containerPreset = WORKLOAD_PRESETS.container;
            const vmPreset = WORKLOAD_PRESETS.vm;

            // --- Calculate Usable Resources ---
            // These are assumptions for this simplified mode.
            const cpuToVcpuRatio = 2; // Assuming hyperthreading
            const maxUtilization = 0.80; // Assuming 80% target
            const loggingStack = 'elasticsearch'; // Assuming ES

            // Per-node calculations
            const totalVcpuPerNode = infra.cpu * cpuToVcpuRatio;
            const cpuReservation = calculateCpuReservation(infra.cpu);
            const memoryReservation = calculateMemoryReservation(infra.memory);
            
            const availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
            const availableMemoryPerNode = infra.memory - memoryReservation;

            // Total cluster resources available on workers
            let totalAvailableVcpu = infra.workers * availableVcpuPerNode;
            let totalAvailableMemory = infra.workers * availableMemoryPerNode;

            // Subtract logging overhead from the total pool
            const loggingOverhead = getLoggingOverhead(loggingStack, infra.workers);
            totalAvailableVcpu -= loggingOverhead.totalCpu;
            totalAvailableMemory -= loggingOverhead.totalMemory;

            // Apply max utilization to get the final usable pool for workloads
            const usableVcpu = totalAvailableVcpu * maxUtilization;
            const usableMemory = totalAvailableMemory * maxUtilization;

            // --- Calculate Capacity ---
            const containerCapacityByCpu = Math.floor(usableVcpu / containerPreset.vcpu);
            const containerCapacityByMem = Math.floor(usableMemory / containerPreset.memory);
            const containerCapacity = Math.min(containerCapacityByCpu, containerCapacityByMem);

            const vmCapacityByCpu = Math.floor(usableVcpu / vmPreset.vcpu);
            const vmCapacityByMem = Math.floor(usableMemory / vmPreset.memory);
            const vmCapacity = Math.min(vmCapacityByCpu, vmCapacityByMem);

            const results = {
                infra,
                usableVcpu,
                usableMemory,
                containerPreset,
                containerCapacity,
                containerLimitingFactor: containerCapacityByCpu < containerCapacityByMem ? 'vCPU' : 'Memory',
                vmPreset,
                vmCapacity,
                vmLimitingFactor: vmCapacityByCpu < vmCapacityByMem ? 'vCPU' : 'Memory',
                subscriptionInfo
            };

            displayCapacityResults(results);
        }

        function displayCapacityResults(results) {
            const resultsContainer = document.getElementById('results-container');

            const resultsHTML = `
                <div class="result-card">
                    <h3>🎯 Custom Infrastructure Summary</h3>
                    <div class="result-item">
                        <span>Number of Worker Nodes:</span>
                        <span class="result-value">${results.infra.workers} nodes</span>
                    </div>
                    <div class="result-item">
                        <span>CPU Cores per Node:</span>
                        <span class="result-value">${results.infra.cpu} Cores</span>
                    </div>
                    <div class="result-item">
                        <span>Memory per Node:</span>
                        <span class="result-value">${results.infra.memory} GB</span>
                    </div>
                    <div class="result-item">
                        <span>Total Usable vCPU (for workloads):</span>
                        <span class="result-value">${results.usableVcpu.toFixed(1)} vCPUs</span>
                    </div>
                    <div class="result-item">
                        <span>Total Usable Memory (for workloads):</span>
                        <span class="result-value">${results.usableMemory.toFixed(1)} GB</span>
                    </div>
                </div>

                <div class="result-card">
                    <h3>📦 Estimated Container Capacity</h3>
                    <div class="result-item">
                        <span>Assumed Container Size:</span>
                        <span class="result-value">${results.containerPreset.vcpu} vCPU / ${results.containerPreset.memory} GB RAM</span>
                    </div>
                    <div class="result-item">
                        <span><strong>Estimated Containers:</strong></span>
                        <span class="result-value" style="font-size: 1.5rem;">~ ${results.containerCapacity}</span>
                    </div>
                    <div class="result-item">
                        <span>Limiting Resource:</span>
                        <span class="result-value">${results.containerLimitingFactor}</span>
                    </div>
                </div>

                ${results.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
                    <div class="result-card">
                        <h3>🖥️ Estimated VM Capacity (OpenShift Virtualization)</h3>
                        <div class="result-item">
                            <span>Assumed VM Size:</span>
                            <span class="result-value">${results.vmPreset.vcpu} vCPU / ${results.vmPreset.memory} GB RAM</span>
                        </div>
                        <div class="result-item">
                            <span><strong>Estimated VMs:</strong></span>
                            <span class="result-value" style="font-size: 1.5rem;">~ ${results.vmCapacity}</span>
                        </div>
                        <div class="result-item">
                            <span>Limiting Resource:</span>
                            <span class="result-value">${results.vmLimitingFactor}</span>
                        </div>
                    </div>
                ` : `<div class="warning">💡 <strong>VM Estimation Not Available:</strong> OpenShift Virtualization requires a socket-based subscription. Please select "Bare-metal (Socket-based)" to estimate VM capacity.</div>`}

                <div class="result-card">
                    <h3>🎟️ OpenShift Subscription Estimate</h3>
                    <div class="result-item">
                        <span>Subscription Model:</span>
                        <span class="result-value">${results.subscriptionInfo.type}</span>
                    </div>
                    <div class="result-item">
                        <span>Total Billable Physical Cores (on ${results.infra.workers} worker nodes):</span>
                        <span class="result-value">${results.subscriptionInfo.totalPhysicalCores} cores</span>
                    </div>
                    ${results.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
                    <div class="result-item">
                        <span>Total Billable Sockets (on ${results.infra.workers} worker nodes):</span>
                        <span class="result-value">${results.subscriptionInfo.totalSockets} sockets</span>
                    </div>
                    ` : ''}
                    <div class="result-item">
                        <span><strong>Required Subscriptions:</strong></span>
                        <span class="result-value" style="font-size: 1.5rem;">${results.subscriptionInfo.count}</span>
                    </div>
                    <div class="warning" style="margin-top: 15px; padding: 10px; text-align: center; background: rgba(0,0,0,0.2);">
                        💡 <strong>Calculation:</strong> ${results.subscriptionInfo.calculationMethod}
                    </div>
                </div>

                <div class="warning">
                    💡 <strong>Note:</strong> These are estimates based on a standard OpenShift deployment with dedicated master/infra nodes and typical overhead. For precise calculations, use the Resource Sizing mode.
                </div>
            `;

            resultsContainer.innerHTML = resultsHTML;
            document.getElementById('exportBtn').style.display = 'none';
        }

        // Initialize
        window.onload = function() {
            loadInputsFromLocalStorage();
        };
    </script>
</body>
</html>
