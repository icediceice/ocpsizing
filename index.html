<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenShift Resource Planning Calculator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-direction: column;
        }

        .input-section {
            padding: 40px;
            background: #f8f9fa;
            border-bottom: 3px solid #ee0979;
        }

        .results-section {
            padding: 40px;
            background: white;
            position: relative;
        }

        .results-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 40px;
            right: 40px;
            height: 1px;
            background: linear-gradient(90deg, transparent 0%, #e9ecef 50%, transparent 100%);
        }

        .section-title {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 25px;
            padding-bottom: 10px;
            border-bottom: 3px solid #ee0979;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #ee0979;
            box-shadow: 0 0 0 3px rgba(238, 9, 121, 0.1);
        }

        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .radio-option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .radio-option:hover {
            border-color: #ee0979;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .radio-option.selected {
            border-color: #ee0979;
            background: linear-gradient(135deg, #ee0979, #ff6a00);
            color: white;
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option h3 {
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .radio-option p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .checkbox-group {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
        }

        .checkbox-item:last-child {
            margin-bottom: 0;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin-right: 10px;
            transform: scale(1.2);
        }

        .workload-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .workload-header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .workload-content {
            padding: 20px;
        }

        .workload-item {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            position: relative;
            overflow: hidden;
        }

        .workload-item:last-child {
            margin-bottom: 0;
        }

        .workload-inputs {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1.3fr;
            gap: 15px;
            align-items: end;
        }

        .workload-field {
            display: flex;
            flex-direction: column;
        }

        .workload-field label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #555;
            margin-bottom: 5px;
        }

        .workload-field input {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .workload-field input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 2px rgba(79, 172, 254, 0.1);
        }

        .remove-workload {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s ease;
        }

        .remove-workload:hover {
            background: #c82333;
            transform: scale(1.1);
        }

        .add-workload-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-top: 15px;
        }

        .add-workload-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 10px rgba(79, 172, 254, 0.3);
        }

        .logging-storage-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
        }

        .logging-storage-header {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logging-storage-content {
            padding: 20px;
            display: none;
        }

        .logging-storage-content.active {
            display: block;
        }

        .storage-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .growth-section {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }

        .growth-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .growth-content {
            padding: 20px;
            display: none;
        }

        .growth-content.active {
            display: block;
        }

        .growth-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .calculate-btn {
            background: linear-gradient(135deg, #ee0979 0%, #ff6a00 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease;
            width: 100%;
            margin-top: 30px;
        }

        .export-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.3s ease;
            margin-left: 15px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .export-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.3);
        }

        .btn-container {
            display: flex;
            align-items: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        .btn-container .calculate-btn {
            flex: 1;
            margin: 0;
        }

        .calculate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(238, 9, 121, 0.3);
        }

        .result-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .result-card h3 {
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .warning {
            background: linear-gradient(135deg, #ff9a56 0%, #ff6b95 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
        }

        .success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: 500;
        }

        .info-tooltip {
            display: inline-block;
            background: #667eea;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            text-align: center;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            cursor: help;
            line-height: 20px;
        }

        .breakdown-section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .breakdown-title {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .breakdown-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .breakdown-item:last-child {
            border-bottom: none;
        }

        .storage-breakdown {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
        }

        .growth-chart-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .growth-projections {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .projection-card {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
        }

        .projection-card h4 {
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .projection-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        .recommendation-card {
            background: linear-gradient(135deg, #ff6b95 0%, #ff9a56 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .recommendation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
        }

        .recommendation-status {
            font-weight: bold;
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .status-urgent { background: #dc3545; }
        .status-warning { background: #ffc107; color: #000; }
        .status-caution { background: #fd7e14; }
        .status-ok { background: #28a745; }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .radio-group {
                grid-template-columns: 1fr;
            }

            .workload-inputs {
                grid-template-columns: 1fr;
            }

            .growth-inputs, .storage-inputs {
                grid-template-columns: 1fr;
            }

            .growth-projections {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ OpenShift Resource Calculator</h1>
            <p>Plan your cluster resources with precision - including multiple workloads, logging, monitoring, storage requirements, and growth projections</p>
        </div>

        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">üìä Configuration</h2>

                <!-- Logging Stack Selection -->
                <div class="form-group">
                    <label>Choose Logging Stack:</label>
                    <div class="radio-group">
                        <div class="radio-option selected" onclick="selectLoggingStack('elasticsearch')">
                            <input type="radio" name="loggingStack" value="elasticsearch" checked>
                            <h3>Elasticsearch</h3>
                            <p>Higher infra resources, lower per-node overhead</p>
                        </div>
                        <div class="radio-option" onclick="selectLoggingStack('loki')">
                            <input type="radio" name="loggingStack" value="loki">
                            <h3>LokiStack</h3>
                            <p>Lower infra resources, higher per-node overhead</p>
                        </div>
                    </div>
                </div>

                <!-- Cluster Configuration Options -->
                <div class="form-group">
                    <label>Cluster Configuration:</label>
                    <div class="checkbox-group">
                        <div class="checkbox-item" onclick="toggleCheckbox('mergeMasters')">
                            <input type="checkbox" id="mergeMasters">
                            <label for="mergeMasters">Merge Master nodes with Worker nodes (Compact cluster)</label>
                        </div>
                        <div class="checkbox-item" onclick="toggleCheckbox('mergeInfra')">
                            <input type="checkbox" id="mergeInfra">
                            <label for="mergeInfra">Merge Infrastructure nodes with Worker nodes</label>
                        </div>
                    </div>
                </div>

                <!-- Multiple Workload Specifications -->
                <div class="workload-section">
                    <div class="workload-header">
                        <span>üíª Workload Specifications</span>
                    </div>
                    <div class="workload-content">
                        <div id="workloads-container">
                            <!-- Workloads will be dynamically added here -->
                        </div>
                        <button class="add-workload-btn" onclick="addWorkload()">‚ûï Add Workload Type</button>
                    </div>
                </div>

                <!-- Logging Storage Configuration -->
                <div class="logging-storage-section">
                    <div class="logging-storage-header" onclick="toggleLoggingStorageSection()">
                        <span>üíæ Logging Storage Configuration</span>
                        <span id="storageToggle">‚ñº</span>
                    </div>
                    <div class="logging-storage-content" id="storageContent">
                        <div class="storage-inputs">
                            <div class="form-group">
                                <label for="logVolumePerPod">Log Volume per Pod (MB/day): <span class="info-tooltip" title="Average log volume generated per pod per day">?</span></label>
                                <input type="number" id="logVolumePerPod" value="100" min="1">
                            </div>
                            <div class="form-group">
                                <label for="logRetentionDays">Log Retention (Days): <span class="info-tooltip" title="How long to keep logs before deletion">?</span></label>
                                <input type="number" id="logRetentionDays" value="30" min="1" max="365">
                            </div>
                            <div class="form-group">
                                <label for="compressionRatio">Compression Ratio: <span class="info-tooltip" title="Log compression factor (2 = 50% compression)">?</span></label>
                                <input type="number" id="compressionRatio" value="3" min="1" max="10" step="0.1">
                            </div>
                            <div class="form-group">
                                <label for="replicationFactor">Replication Factor: <span class="info-tooltip" title="Number of copies for HA (Elasticsearch only)">?</span></label>
                                <input type="number" id="replicationFactor" value="1" min="1" max="3">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Worker Node Specifications -->
                <h3 style="margin: 30px 0 20px 0; color: #333;">‚öôÔ∏è Worker Node Specifications</h3>

                <div class="form-group">
                    <label for="cpuCores">Physical CPU Cores per Node: <span class="info-tooltip" title="Physical CPU cores available on each worker node">?</span></label>
                    <input type="number" id="cpuCores" value="8" min="1">
                </div>

                <div class="form-group">
                    <label for="cpuToVcpuRatio">CPU to vCPU Ratio: <span class="info-tooltip" title="How many vCPUs per physical CPU core (e.g., 2 = hyperthreading)">?</span></label>
                    <input type="number" id="cpuToVcpuRatio" value="2" min="1" step="0.1">
                </div>

                <div class="form-group">
                    <label for="memoryPerNode">Memory per Node (GB): <span class="info-tooltip" title="Total memory available on each worker node">?</span></label>
                    <input type="number" id="memoryPerNode" value="32" min="1">
                </div>

                <div class="form-group">
                    <label for="maxUtilization">Max Host Utilization (%): <span class="info-tooltip" title="Maximum resource utilization before provisioning new nodes">?</span></label>
                    <input type="number" id="maxUtilization" value="80" min="50" max="95">
                </div>

                <!-- Growth Projection Module -->
                <div class="growth-section">
                    <div class="growth-header" onclick="toggleGrowthSection()">
                        <span>üìà Growth Projection (Optional)</span>
                        <span id="growthToggle">‚ñº</span>
                    </div>
                    <div class="growth-content" id="growthContent">
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="enableGrowth" onchange="toggleGrowthInputs()"> 
                                Enable Growth Projections
                            </label>
                        </div>
                        <div id="growthInputs" style="display: none;">
                            <div class="growth-inputs">
                                <div class="form-group">
                                    <label for="growthRate">Annual Growth Rate (%):</label>
                                    <input type="number" id="growthRate" value="50" min="0" max="200" step="1">
                                </div>
                                <div class="form-group">
                                    <label for="projectionMonths">Projection Period (Months):</label>
                                    <input type="number" id="projectionMonths" value="12" min="1" max="60">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="btn-container">
                    <button class="calculate-btn" onclick="calculateResources()">üî¢ Calculate Resources</button>
                    <button class="export-btn" onclick="exportToExcel()" id="exportBtn" style="display: none;">üìä Export to Excel</button>
                </div>
            </div>

            <div class="results-section">
                <h2 class="section-title">üìà Results</h2>
                <div id="results-container">
                    <div class="result-card">
                        <h3>üëã Welcome!</h3>
                        <p>Configure your cluster specifications on the left and click "Calculate Resources" to see detailed resource planning recommendations.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedLoggingStack = 'elasticsearch';
        let workloadCounter = 0;
        let workloads = [];

        // Initialize with one default workload
        function initializeWorkloads() {
            addWorkload('Web Applications', 100, 0.5, 1);
        }

        function selectLoggingStack(stack) {
            selectedLoggingStack = stack;
            
            // Update UI
            document.querySelectorAll('.radio-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            event.currentTarget.classList.add('selected');
            
            // Update radio button
            document.querySelector(`input[value="${stack}"]`).checked = true;
        }

        function toggleCheckbox(id) {
            const checkbox = document.getElementById(id);
            checkbox.checked = !checkbox.checked;
        }

        function toggleLoggingStorageSection() {
            const content = document.getElementById('storageContent');
            const toggle = document.getElementById('storageToggle');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('active');
                toggle.textContent = '‚ñ≤';
            }
        }

        function toggleGrowthSection() {
            const content = document.getElementById('growthContent');
            const toggle = document.getElementById('growthToggle');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('active');
                toggle.textContent = '‚ñ≤';
            }
        }

        function toggleGrowthInputs() {
            const enableGrowth = document.getElementById('enableGrowth').checked;
            const growthInputs = document.getElementById('growthInputs');
            growthInputs.style.display = enableGrowth ? 'block' : 'none';
        }

        function addWorkload(name = '', instances = 50, vcpu = 0.5, memory = 1) {
            workloadCounter++;
            const workloadId = `workload-${workloadCounter}`;
            
            const workloadHTML = `
                <div class="workload-item" id="${workloadId}">
                    <button class="remove-workload" onclick="removeWorkload('${workloadId}')" title="Remove workload">√ó</button>
                    <div class="workload-inputs">
                        <div class="workload-field">
                            <label>Workload Name</label>
                            <input type="text" placeholder="e.g., Web Applications" value="${name}" data-field="name">
                        </div>
                        <div class="workload-field">
                            <label>Instances</label>
                            <input type="number" placeholder="100" value="${instances}" min="1" data-field="instances">
                        </div>
                        <div class="workload-field">
                            <label>vCPU/Instance</label>
                            <input type="number" placeholder="0.5" value="${vcpu}" min="0.1" step="0.1" data-field="vcpu">
                        </div>
                        <div class="workload-field">
                            <label>Memory/Instance (GB)</label>
                            <input type="number" placeholder="1.0" value="${memory}" min="0.1" step="0.1" data-field="memory">
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('workloads-container').insertAdjacentHTML('beforeend', workloadHTML);
            updateWorkloads();
        }

        function removeWorkload(workloadId) {
            document.getElementById(workloadId).remove();
            updateWorkloads();
        }

        function updateWorkloads() {
            workloads = [];
            const workloadElements = document.querySelectorAll('.workload-item');
            
            workloadElements.forEach(element => {
                const inputs = element.querySelectorAll('input');
                const workload = {
                    name: inputs[0].value || 'Unnamed Workload',
                    instances: parseInt(inputs[1].value) || 0,
                    vcpu: parseFloat(inputs[2].value) || 0,
                    memory: parseFloat(inputs[3].value) || 0
                };
                workloads.push(workload);
            });
        }

        function calculateCpuReservation(totalCpuCores) {
            let reservation = 0;
            
            if (totalCpuCores >= 1) {
                reservation += 1 * 0.06; // First CPU: 6%
            }
            if (totalCpuCores >= 2) {
                reservation += 1 * 0.01; // Second CPU: 1%
            }
            if (totalCpuCores >= 3) {
                let cores3to4 = Math.min(totalCpuCores - 2, 2);
                reservation += cores3to4 * 0.005; // 3rd-4th CPU: 0.5%
            }
            if (totalCpuCores > 4) {
                let remainingCores = totalCpuCores - 4;
                reservation += remainingCores * 0.0025; // Remaining: 0.25%
            }
            
            return reservation;
        }

        function calculateMemoryReservation(totalMemoryGB) {
            let reservation = 0;
            
            // 25% of first 4 GB
            let first4GB = Math.min(totalMemoryGB, 4);
            reservation += first4GB * 0.25;
            
            // 20% of next 4 GB (GB 4-8)
            if (totalMemoryGB > 4) {
                let next4GB = Math.min(totalMemoryGB - 4, 4);
                reservation += next4GB * 0.20;
            }
            
            // 10% of next 8 GB (GB 8-16)
            if (totalMemoryGB > 8) {
                let next8GB = Math.min(totalMemoryGB - 8, 8);
                reservation += next8GB * 0.10;
            }
            
            // 6% of next 112 GB (GB 16-128)
            if (totalMemoryGB > 16) {
                let next112GB = Math.min(totalMemoryGB - 16, 112);
                reservation += next112GB * 0.06;
            }
            
            // 2% of remaining memory (GB 128+)
            if (totalMemoryGB > 128) {
                let remaining = totalMemoryGB - 128;
                reservation += remaining * 0.02;
            }
            
            return reservation;
        }

        function calculateLogStorageRequirements() {
            const logVolumePerPod = parseFloat(document.getElementById('logVolumePerPod').value);
            const retentionDays = parseInt(document.getElementById('logRetentionDays').value);
            const compressionRatio = parseFloat(document.getElementById('compressionRatio').value);
            const replicationFactor = parseInt(document.getElementById('replicationFactor').value);

            // Calculate total pods across all workloads
            const totalPods = workloads.reduce((sum, workload) => sum + workload.instances, 0);
            
            // Calculate raw log volume
            const dailyRawLogVolume = totalPods * logVolumePerPod; // MB/day
            const totalRawLogVolume = dailyRawLogVolume * retentionDays; // MB total
            
            // Apply compression
            const compressedLogVolume = totalRawLogVolume / compressionRatio;
            
            // Add infrastructure logs (estimated at 20% of application logs)
            const infraLogVolume = compressedLogVolume * 0.2;
            const totalLogVolume = compressedLogVolume + infraLogVolume;
            
            // Apply replication factor (for Elasticsearch)
            let storageWithReplication = totalLogVolume;
            if (selectedLoggingStack === 'elasticsearch') {
                storageWithReplication = totalLogVolume * replicationFactor;
            }
            
            // Add safety margin (20%)
            const finalStorageRequirement = storageWithReplication * 1.2;
            
            // Convert to GB
            const storageRequirementGB = finalStorageRequirement / 1024;
            
            return {
                totalPods,
                dailyRawLogVolumeMB: dailyRawLogVolume,
                totalRawLogVolumeMB: totalRawLogVolume,
                compressedLogVolumeMB: compressedLogVolume,
                infraLogVolumeMB: infraLogVolume,
                totalLogVolumeMB: totalLogVolume,
                storageWithReplicationMB: storageWithReplication,
                finalStorageRequirementGB: storageRequirementGB,
                retentionDays,
                compressionRatio,
                replicationFactor
            };
        }

        function getMasterNodeRequirements() {
            // Master node resource requirements (per master)
            return {
                cpu: 2, // 2 vCPUs per master
                memory: 8 // 8 GB per master
            };
        }

        function getLoggingOverhead(stack, workerNodes) {
            if (stack === 'elasticsearch') {
                return {
                    memoryPerNode: 0.786, // 786Mi in GB
                    cpuPerNode: 0.25, // 250m in cores
                    totalMemory: workerNodes * 0.786,
                    totalCpu: workerNodes * 0.25
                };
            } else {
                return {
                    memoryPerNode: 2.05, // 2Gi + 50Mi in GB
                    cpuPerNode: 0.25, // 250m in cores
                    totalMemory: workerNodes * 2.05,
                    totalCpu: workerNodes * 0.25
                };
            }
        }

        function getInfrastructureRequirements(stack, clusterSize) {
            const loggingInfra = {
                elasticsearch: {
                    small: { memory: 49, cpu: 10, storage: 800 },
                    medium: { memory: 125, cpu: 15, storage: 2000 },
                    large: { memory: 280, cpu: 30, storage: 4000 }
                },
                loki: {
                    small: { memory: 16, cpu: 10, storage: 300 },
                    medium: { memory: 25, cpu: 18, storage: 600 },
                    large: { memory: 47, cpu: 35, storage: 1200 }
                }
            };

            const monitoring = {
                small: { memory: 10.6, cpu: 5, storage: 200 },
                medium: { memory: 25, cpu: 8, storage: 400 },
                large: { memory: 50, cpu: 15, storage: 800 }
            };

            let sizeCategory;
            if (clusterSize < 50) sizeCategory = 'small';
            else if (clusterSize < 250) sizeCategory = 'medium';
            else sizeCategory = 'large';

            const logging = loggingInfra[stack][sizeCategory];
            const mon = monitoring[sizeCategory];

            return {
                totalMemory: logging.memory + mon.memory,
                totalCpu: logging.cpu + mon.cpu,
                totalStorage: logging.storage + mon.storage,
                loggingMemory: logging.memory,
                monitoringMemory: mon.memory,
                recommendedNodes: sizeCategory === 'small' ? 3 : sizeCategory === 'medium' ? 3 : 6
            };
        }

        function calculateGrowthProjections(baseWorkloads, annualGrowthRate, months, usableVcpuPerNode, usableMemoryPerNode, maxUtilization, currentWorkerNodes) {
            const projections = [];
            const maxUtilizationPercent = maxUtilization * 100;
            
            // Convert annual growth rate to monthly growth rate
            const monthlyGrowthRate = Math.pow(1 + (annualGrowthRate / 100), 1/12) - 1;
            
            let firstUrgentMonth = null;
            let firstWarningMonth = null;
            let firstCautionMonth = null;
            
            for (let month = 0; month <= months; month++) {
                const growthFactor = month === 0 ? 1 : Math.pow(1 + monthlyGrowthRate, month);
                
                const projectedWorkloads = baseWorkloads.map(workload => ({
                    ...workload,
                    instances: Math.ceil(workload.instances * growthFactor)
                }));
                
                const totalInstances = projectedWorkloads.reduce((sum, w) => sum + w.instances, 0);
                const totalVcpu = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.vcpu), 0);
                const totalMemory = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.memory), 0);
                
                // Use current worker nodes as starting point for month 0, then calculate optimal
                let optimalWorkerNodes;
                if (month === 0) {
                    optimalWorkerNodes = currentWorkerNodes;
                } else {
                    const nodesForCpu = Math.ceil(totalVcpu / usableVcpuPerNode);
                    const nodesForMemory = Math.ceil(totalMemory / usableMemoryPerNode);
                    optimalWorkerNodes = Math.max(nodesForCpu, nodesForMemory, 3); // minimum 3 for HA
                }
                
                // Calculate utilization with current nodes (or optimal for month 0)
                const availableVcpu = optimalWorkerNodes * usableVcpuPerNode;
                const availableMemory = optimalWorkerNodes * usableMemoryPerNode;
                
                const cpuUtilization = (totalVcpu / availableVcpu) * 100;
                const memoryUtilization = (totalMemory / availableMemory) * 100;
                const maxCurrentUtilization = Math.max(cpuUtilization, memoryUtilization);
                
                // Determine if expansion is needed
                const needsExpansion = maxCurrentUtilization > maxUtilizationPercent;
                
                // Calculate growth from previous month
                let utilizationGrowth = 0;
                if (month > 0 && projections.length > 0) {
                    utilizationGrowth = maxCurrentUtilization - projections[projections.length - 1].maxUtilization;
                }
                
                // Recommendation logic - only set once for the first occurrence
                let recommendation = '';
                let showRecommendation = false;
                
                if (maxCurrentUtilization > maxUtilizationPercent + 5) {
                    recommendation = 'URGENT: Add nodes immediately';
                    if (firstUrgentMonth === null) {
                        firstUrgentMonth = month;
                        showRecommendation = true;
                    }
                } else if (maxCurrentUtilization > maxUtilizationPercent) {
                    recommendation = 'WARNING: Plan node expansion';
                    if (firstWarningMonth === null && firstUrgentMonth === null) {
                        firstWarningMonth = month;
                        showRecommendation = true;
                    }
                } else if (maxCurrentUtilization > maxUtilizationPercent - 10) {
                    recommendation = 'CAUTION: Monitor closely';
                    if (firstCautionMonth === null && firstWarningMonth === null && firstUrgentMonth === null) {
                        firstCautionMonth = month;
                        showRecommendation = true;
                    }
                } else {
                    recommendation = 'OK: Capacity sufficient';
                }
                
                projections.push({
                    month: month,
                    workloads: projectedWorkloads,
                    totalInstances: totalInstances,
                    totalVcpu: totalVcpu,
                    totalMemory: totalMemory,
                    optimalWorkerNodes: optimalWorkerNodes,
                    cpuUtilization: cpuUtilization,
                    memoryUtilization: memoryUtilization,
                    maxUtilization: maxCurrentUtilization,
                    utilizationGrowth: utilizationGrowth,
                    needsExpansion: needsExpansion,
                    recommendation: recommendation,
                    showRecommendation: showRecommendation,
                    growthFactor: growthFactor,
                    monthlyGrowthRate: monthlyGrowthRate * 100 // Store as percentage for display
                });
            }
            
            return projections;
        }

        function exportToExcel() {
            if (!window.lastCalculationResults) {
                alert('Please calculate resources first before exporting');
                return;
            }

            const calc = window.lastCalculationResults;
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Summary sheet
            const summaryData = [
                ['OpenShift Resource Planning Calculator'],
                ['Generated on:', new Date().toLocaleString()],
                [''],
                ['Cluster Summary'],
                ['Worker Nodes Required:', calc.finalWorkerNodes],
                ['Master Nodes:', calc.mergeMasters ? '0 (merged)' : calc.masterNodes],
                ['Infrastructure Nodes:', calc.mergeInfra ? '0 (merged)' : calc.infraNodes],
                ['Total Cluster Size:', calc.totalClusterNodes],
                ['Configuration:', calc.mergeMasters && calc.mergeInfra ? 'Compact cluster (Masters + Infrastructure merged)' : 
                                  calc.mergeMasters ? 'Compact cluster (Masters merged)' : 
                                  calc.mergeInfra ? 'Infrastructure merged' : 'Dedicated nodes'],
                [''],
                ['Workload Requirements'],
                ['Total Application Instances:', calc.totalInstances],
                ['Total vCPU Needed:', calc.totalVcpuNeeded.toFixed(1)],
                ['Total Memory Needed (GB):', calc.totalMemoryNeeded.toFixed(1)],
                ['Logging Stack:', selectedLoggingStack === 'elasticsearch' ? 'Elasticsearch' : 'LokiStack'],
                [''],
                ['Worker Node Capacity'],
                ['Physical CPU Cores:', calc.cpuCores],
                ['Total vCPUs per Node:', calc.totalVcpuPerNode],
                ['Available vCPUs (after OS):', calc.availableVcpuPerNode.toFixed(2)],
                ['Available Memory (after OS) (GB):', calc.availableMemoryPerNode.toFixed(1)],
                [''],
                ['Utilization Analysis'],
                ['CPU Utilization (%):', calc.actualCpuUtilization.toFixed(1)],
                ['Memory Utilization (%):', calc.actualMemoryUtilization.toFixed(1)],
                ['Max Utilization Target (%):', calc.maxUtilization],
                [''],
                ['Log Storage Requirements'],
                ['Total Pods Generating Logs:', calc.logStorage.totalPods],
                ['Daily Raw Log Volume (GB):', (calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)],
                ['Total Storage Required (GB):', calc.logStorage.finalStorageRequirementGB.toFixed(1)],
                ['Retention Period (days):', calc.logStorage.retentionDays],
                ['Compression Ratio:', calc.logStorage.compressionRatio + ':1']
            ];
            
            const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
            
            // Workloads sheet
            const workloadData = [
                ['Workload Breakdown'],
                ['Name', 'Instances', 'vCPU per Instance', 'Memory per Instance (GB)', 'Total vCPU', 'Total Memory (GB)']
            ];
            
            calc.workloads.forEach(workload => {
                workloadData.push([
                    workload.name,
                    workload.instances,
                    workload.vcpu,
                    workload.memory,
                    (workload.instances * workload.vcpu).toFixed(1),
                    (workload.instances * workload.memory).toFixed(1)
                ]);
            });
            
            const workloadWs = XLSX.utils.aoa_to_sheet(workloadData);
            XLSX.utils.book_append_sheet(wb, workloadWs, 'Workloads');
            
            // Growth projections sheet (if available)
            if (calc.growthProjections) {
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
                
                const growthData = [
                    ['Growth Projections'],
                    ['Annual Growth Rate (%):', annualGrowthRate],
                    ['Equivalent Monthly Growth Rate (%):', monthlyGrowthRate.toFixed(3)],
                    [''],
                    ['Month', 'Total Instances', 'Total vCPU', 'Total Memory (GB)', 'Optimal Nodes', 'CPU Utilization (%)', 'Memory Utilization (%)', 'Max Utilization (%)', 'Utilization Growth (%)', 'Recommendation', 'Show Alert']
                ];
                
                calc.growthProjections.forEach(proj => {
                    growthData.push([
                        proj.month,
                        proj.totalInstances,
                        proj.totalVcpu.toFixed(1),
                        proj.totalMemory.toFixed(1),
                        proj.optimalWorkerNodes,
                        proj.cpuUtilization.toFixed(1),
                        proj.memoryUtilization.toFixed(1),
                        proj.maxUtilization.toFixed(1),
                        proj.utilizationGrowth.toFixed(1),
                        proj.recommendation,
                        proj.showRecommendation ? 'YES' : 'NO'
                    ]);
                });
                
                const growthWs = XLSX.utils.aoa_to_sheet(growthData);
                XLSX.utils.book_append_sheet(wb, growthWs, 'Growth Projections');
            }
            
            // Save file
            const fileName = `OpenShift_Resource_Plan_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function createGrowthChart(projections, maxUtilizationThreshold) {
            const canvas = document.getElementById('growthChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (window.growthChartInstance) {
                window.growthChartInstance.destroy();
            }
            
            // Create threshold line data
            const thresholdData = projections.map(() => maxUtilizationThreshold);
            const warningThresholdData = projections.map(() => maxUtilizationThreshold + 10);
            
            window.growthChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: projections.map(p => `Month ${p.month}`),
                    datasets: [
                        {
                            label: 'Cluster Utilization (%)',
                            data: projections.map(p => p.maxUtilization),
                            borderColor: '#ee0979',
                            backgroundColor: 'rgba(238, 9, 121, 0.1)',
                            tension: 0.4,
                            fill: false,
                            pointRadius: 5,
                            pointHoverRadius: 8
                        },
                        {
                            label: 'Target Threshold',
                            data: thresholdData,
                            borderColor: '#28a745',
                            backgroundColor: 'transparent',
                            borderDash: [5, 5],
                            tension: 0,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        },
                        {
                            label: 'Warning Threshold',
                            data: warningThresholdData,
                            borderColor: '#ffc107',
                            backgroundColor: 'transparent',
                            borderDash: [10, 5],
                            tension: 0,
                            fill: false,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Timeline'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Utilization (%)'
                            },
                            min: 0,
                            max: Math.max(100, Math.max(...projections.map(p => p.maxUtilization)) + 10)
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Growth Projection: Cluster Utilization Over Time'
                        },
                        legend: {
                            display: true
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    if (context[0].datasetIndex === 0) {
                                        const projection = projections[context[0].dataIndex];
                                        return [
                                            `Instances: ${projection.totalInstances}`,
                                            `vCPU Usage: ${projection.totalVcpu.toFixed(1)}`,
                                            `Memory Usage: ${projection.totalMemory.toFixed(1)} GB`,
                                            `Recommendation: ${projection.recommendation}`
                                        ];
                                    }
                                    return null;
                                }
                            }
                        }
                    }
                }
            });
        }

        function calculateResources() {
            // Update workloads from UI
            updateWorkloads();
            
            if (workloads.length === 0) {
                alert('Please add at least one workload type');
                return;
            }

            // Calculate total workload requirements
            const totalInstances = workloads.reduce((sum, workload) => sum + workload.instances, 0);
            const totalVcpuNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.vcpu), 0);
            const totalMemoryNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.memory), 0);

            // Calculate log storage requirements
            const logStorage = calculateLogStorageRequirements();

            // Get worker node specifications
            const cpuCores = parseInt(document.getElementById('cpuCores').value);
            const cpuToVcpuRatio = parseFloat(document.getElementById('cpuToVcpuRatio').value);
            const memoryPerNode = parseInt(document.getElementById('memoryPerNode').value);
            const maxUtilization = parseInt(document.getElementById('maxUtilization').value) / 100;
            
            // Get merge options
            const mergeMasters = document.getElementById('mergeMasters').checked;
            const mergeInfra = document.getElementById('mergeInfra').checked;

            // Calculate worker node capacity
            const totalVcpuPerNode = cpuCores * cpuToVcpuRatio;
            
            // Calculate OpenShift reservations
            const cpuReservation = calculateCpuReservation(cpuCores);
            const memoryReservation = calculateMemoryReservation(memoryPerNode);
            
            // Available resources after OpenShift reservations
            let availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
            let availableMemoryPerNode = memoryPerNode - memoryReservation;
            
            // Account for master node requirements if merged
            let masterOverhead = { cpu: 0, memory: 0 };
            if (mergeMasters) {
                const masterReqs = getMasterNodeRequirements();
                masterOverhead.cpu = masterReqs.cpu;
                masterOverhead.memory = masterReqs.memory;
                availableVcpuPerNode -= masterReqs.cpu;
                availableMemoryPerNode -= masterReqs.memory;
            }
            
            // Calculate usable resources considering max utilization
            const usableVcpuPerNode = availableVcpuPerNode * maxUtilization;
            const usableMemoryPerNode = availableMemoryPerNode * maxUtilization;
            
            // Calculate worker nodes needed (before logging overhead)
            const nodesForCpu = Math.ceil(totalVcpuNeeded / usableVcpuPerNode);
            const nodesForMemory = Math.ceil(totalMemoryNeeded / usableMemoryPerNode);
            let baseWorkerNodes = Math.max(nodesForCpu, nodesForMemory);
            
            // For merged masters, ensure minimum 3 nodes for HA
            if (mergeMasters) {
                baseWorkerNodes = Math.max(baseWorkerNodes, 3);
            }
            
            // Account for logging overhead and recalculate
            let finalWorkerNodes = baseWorkerNodes;
            let iterations = 0;
            const maxIterations = 10;
            
            while (iterations < maxIterations) {
                const loggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
                
                // Total requirements including logging overhead
                let totalVcpuWithLogging = totalVcpuNeeded + loggingOverhead.totalCpu;
                let totalMemoryWithLogging = totalMemoryNeeded + loggingOverhead.totalMemory;
                
                // Add infrastructure overhead if merged
                let infraOverhead = { cpu: 0, memory: 0 };
                if (mergeInfra) {
                    const totalClusterNodesEstimate = 3 + finalWorkerNodes; // masters + workers
                    const infraReqs = getInfrastructureRequirements(selectedLoggingStack, totalClusterNodesEstimate);
                    infraOverhead.cpu = infraReqs.totalCpu;
                    infraOverhead.memory = infraReqs.totalMemory;
                    totalVcpuWithLogging += infraReqs.totalCpu;
                    totalMemoryWithLogging += infraReqs.totalMemory;
                }
                
                // Calculate new worker node requirements
                const newNodesForCpu = Math.ceil(totalVcpuWithLogging / usableVcpuPerNode);
                const newNodesForMemory = Math.ceil(totalMemoryWithLogging / usableMemoryPerNode);
                let newWorkerNodes = Math.max(newNodesForCpu, newNodesForMemory);
                
                // Ensure minimum nodes for merged configurations
                if (mergeMasters) {
                    newWorkerNodes = Math.max(newWorkerNodes, 3);
                }
                if (mergeInfra) {
                    newWorkerNodes = Math.max(newWorkerNodes, 3);
                }
                
                if (newWorkerNodes === finalWorkerNodes) {
                    break; // Converged
                }
                
                finalWorkerNodes = newWorkerNodes;
                iterations++;
            }

            // Calculate final cluster size
            const masterNodes = mergeMasters ? 0 : 3;
            const infraNodes = mergeInfra ? 0 : 3;
            const totalClusterNodes = masterNodes + infraNodes + finalWorkerNodes;
            
            // Get infrastructure requirements
            const infraReqs = getInfrastructureRequirements(selectedLoggingStack, totalClusterNodes);
            const finalLoggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
            
            // Calculate final overhead
            let finalInfraOverhead = { cpu: 0, memory: 0 };
            if (mergeInfra) {
                finalInfraOverhead.cpu = infraReqs.totalCpu;
                finalInfraOverhead.memory = infraReqs.totalMemory;
            }
            
            // Calculate actual utilization
            let totalVcpuWithLogging = totalVcpuNeeded + finalLoggingOverhead.totalCpu + finalInfraOverhead.cpu;
            let totalMemoryWithLogging = totalMemoryNeeded + finalLoggingOverhead.totalMemory + finalInfraOverhead.memory;
            
            // Account for master overhead in utilization calculation
            if (mergeMasters) {
                totalVcpuWithLogging += masterOverhead.cpu * finalWorkerNodes;
                totalMemoryWithLogging += masterOverhead.memory * finalWorkerNodes;
            }
            
            const actualCpuUtilization = (totalVcpuWithLogging / (finalWorkerNodes * availableVcpuPerNode)) * 100;
            const actualMemoryUtilization = (totalMemoryWithLogging / (finalWorkerNodes * availableMemoryPerNode)) * 100;

            // Growth projections
            let growthProjections = null;
            if (document.getElementById('enableGrowth').checked) {
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const projectionMonths = parseInt(document.getElementById('projectionMonths').value);
                
                growthProjections = calculateGrowthProjections(
                    workloads, 
                    annualGrowthRate, 
                    projectionMonths, 
                    usableVcpuPerNode, 
                    usableMemoryPerNode, 
                    maxUtilization,
                    finalWorkerNodes
                );
            }

            // Store results for export
            window.lastCalculationResults = {
                workloads,
                totalInstances,
                totalVcpuNeeded,
                totalMemoryNeeded,
                logStorage,
                cpuCores,
                cpuToVcpuRatio,
                totalVcpuPerNode,
                memoryPerNode,
                cpuReservation,
                memoryReservation,
                availableVcpuPerNode: availableVcpuPerNode + (mergeMasters ? masterOverhead.cpu : 0),
                availableMemoryPerNode: availableMemoryPerNode + (mergeMasters ? masterOverhead.memory : 0),
                usableVcpuPerNode,
                usableMemoryPerNode,
                finalWorkerNodes,
                masterNodes,
                infraNodes,
                totalClusterNodes,
                infraReqs,
                finalLoggingOverhead,
                actualCpuUtilization,
                actualMemoryUtilization,
                maxUtilization: maxUtilization * 100,
                totalVcpuWithLogging,
                totalMemoryWithLogging,
                mergeMasters,
                mergeInfra,
                masterOverhead,
                finalInfraOverhead,
                growthProjections
            };

            // Display results
            displayResults(window.lastCalculationResults);
        }

        function displayResults(calc) {
            const resultsContainer = document.getElementById('results-container');
            
            let clusterConfigText = '';
            if (calc.mergeMasters && calc.mergeInfra) {
                clusterConfigText = 'Compact cluster (Masters + Infrastructure merged with Workers)';
            } else if (calc.mergeMasters) {
                clusterConfigText = 'Compact cluster (Masters merged with Workers)';
            } else if (calc.mergeInfra) {
                clusterConfigText = 'Infrastructure merged with Workers';
            } else {
                clusterConfigText = 'Dedicated nodes configuration';
            }

            // Create workload breakdown
            let workloadBreakdown = '';
            calc.workloads.forEach(workload => {
                const totalVcpu = workload.instances * workload.vcpu;
                const totalMemory = workload.instances * workload.memory;
                workloadBreakdown += `
                    <div class="breakdown-item">
                        <span>${workload.name} (${workload.instances} instances):</span>
                        <span>${totalVcpu.toFixed(1)} vCPUs, ${totalMemory.toFixed(1)} GB</span>
                    </div>
                `;
            });

            let resultsHTML = `
                <div class="result-card">
                    <h3>üéØ Cluster Summary</h3>
                    <div class="result-item">
                        <span>Worker Nodes Required:</span>
                        <span class="result-value">${calc.finalWorkerNodes} nodes</span>
                    </div>
                    <div class="result-item">
                        <span>Master Nodes:</span>
                        <span class="result-value">${calc.mergeMasters ? '0 (merged)' : calc.masterNodes + ' nodes'}</span>
                    </div>
                    <div class="result-item">
                        <span>Infrastructure Nodes:</span>
                        <span class="result-value">${calc.mergeInfra ? '0 (merged)' : calc.infraNodes + ' nodes'}</span>
                    </div>
                    <div class="result-item">
                        <span>Total Cluster Size:</span>
                        <span class="result-value">${calc.totalClusterNodes} nodes</span>
                    </div>
                    <div class="result-item">
                        <span>Configuration:</span>
                        <span class="result-value">${clusterConfigText}</span>
                    </div>
                </div>

                <div class="result-card">
                    <h3>üíª Workload Requirements</h3>
                    <div class="result-item">
                        <span>Total Application Instances:</span>
                        <span class="result-value">${calc.totalInstances}</span>
                    </div>
                    <div class="result-item">
                        <span>Total vCPU Needed:</span>
                        <span class="result-value">${calc.totalVcpuNeeded.toFixed(1)} vCPUs</span>
                    </div>
                    <div class="result-item">
                        <span>Total Memory Needed:</span>
                        <span class="result-value">${calc.totalMemoryNeeded.toFixed(1)} GB</span>
                    </div>
                    <div class="result-item">
                        <span>Workload Types:</span>
                        <span class="result-value">${calc.workloads.length} types</span>
                    </div>
                </div>

                <div class="breakdown-section">
                    <div class="breakdown-title">üìä Workload Breakdown</div>
                    ${workloadBreakdown}
                </div>

                <div class="storage-breakdown">
                    <h3>üíæ Log Storage Requirements</h3>
                    <div class="result-item">
                        <span>Total Pods Generating Logs:</span>
                        <span class="result-value">${calc.logStorage.totalPods}</span>
                    </div>
                    <div class="result-item">
                        <span>Daily Raw Log Volume:</span>
                        <span class="result-value">${(calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)} GB/day</span>
                    </div>
                    <div class="result-item">
                        <span>Compressed + Infrastructure Logs:</span>
                        <span class="result-value">${(calc.logStorage.totalLogVolumeMB / 1024).toFixed(1)} GB</span>
                    </div>
                    <div class="result-item">
                        <span>Total Storage Required:</span>
                        <span class="result-value">${calc.logStorage.finalStorageRequirementGB.toFixed(1)} GB</span>
                    </div>
                    <div class="result-item">
                        <span>Retention Period:</span>
                        <span class="result-value">${calc.logStorage.retentionDays} days</span>
                    </div>
                    <div class="result-item">
                        <span>Compression Ratio:</span>
                        <span class="result-value">${calc.logStorage.compressionRatio}:1</span>
                    </div>
                    ${selectedLoggingStack === 'elasticsearch' ? `
                    <div class="result-item">
                        <span>Replication Factor:</span>
                        <span class="result-value">${calc.logStorage.replicationFactor}x</span>
                    </div>
                    ` : ''}
                </div>

                <div class="result-card">
                    <h3>‚öôÔ∏è Worker Node Capacity</h3>
                    <div class="result-item">
                        <span>Physical CPU Cores:</span>
                        <span class="result-value">${calc.cpuCores} cores</span>
                    </div>
                    <div class="result-item">
                        <span>Total vCPUs per Node:</span>
                        <span class="result-value">${calc.totalVcpuPerNode} vCPUs</span>
                    </div>
                    <div class="result-item">
                        <span>Available vCPUs (after OS):</span>
                        <span class="result-value">${calc.availableVcpuPerNode.toFixed(2)} vCPUs</span>
                    </div>
                    <div class="result-item">
                        <span>Available Memory (after OS):</span>
                        <span class="result-value">${calc.availableMemoryPerNode.toFixed(1)} GB</span>
                    </div>
                </div>

                <div class="breakdown-section">
                    <div class="breakdown-title">üìä Resource Breakdown</div>
                    <div class="breakdown-item">
                        <span>OpenShift CPU Reservation:</span>
                        <span>${calc.cpuReservation.toFixed(3)} cores (${((calc.cpuReservation/calc.cpuCores)*100).toFixed(1)}%)</span>
                    </div>
                    <div class="breakdown-item">
                        <span>OpenShift Memory Reservation:</span>
                        <span>${calc.memoryReservation.toFixed(1)} GB (${((calc.memoryReservation/calc.memoryPerNode)*100).toFixed(1)}%)</span>
                    </div>
            `;

            if (calc.mergeMasters) {
                resultsHTML += `
                    <div class="breakdown-item">
                        <span>Master Services Overhead:</span>
                        <span>${calc.masterOverhead.cpu} vCPUs, ${calc.masterOverhead.memory} GB per node</span>
                    </div>
                `;
            }

            if (calc.mergeInfra) {
                resultsHTML += `
                    <div class="breakdown-item">
                        <span>Infrastructure Services Overhead:</span>
                        <span>${calc.finalInfraOverhead.cpu} vCPUs, ${calc.finalInfraOverhead.memory} GB total</span>
                    </div>
                `;
            }

            resultsHTML += `
                    <div class="breakdown-item">
                        <span>Logging Overhead per Node:</span>
                        <span>${calc.finalLoggingOverhead.memoryPerNode.toFixed(2)} GB memory, ${(calc.finalLoggingOverhead.cpuPerNode*1000).toFixed(0)}m CPU</span>
                    </div>
                    <div class="breakdown-item">
                        <span>Total Logging Overhead:</span>
                        <span>${calc.finalLoggingOverhead.totalMemory.toFixed(1)} GB memory, ${calc.finalLoggingOverhead.totalCpu.toFixed(1)} vCPUs</span>
                    </div>
                </div>
            `;

            if (!calc.mergeInfra) {
                resultsHTML += `
                    <div class="result-card">
                        <h3>üèóÔ∏è Infrastructure Requirements</h3>
                        <div class="result-item">
                            <span>Infrastructure Memory:</span>
                            <span class="result-value">${calc.infraReqs.totalMemory} GB</span>
                        </div>
                        <div class="result-item">
                            <span>Infrastructure CPU:</span>
                            <span class="result-value">${calc.infraReqs.totalCpu} cores</span>
                        </div>
                        <div class="result-item">
                            <span>Infrastructure Storage:</span>
                            <span class="result-value">${calc.infraReqs.totalStorage} GB</span>
                        </div>
                        <div class="result-item">
                            <span>Recommended Infra Nodes:</span>
                            <span class="result-value">${calc.infraReqs.recommendedNodes} nodes</span>
                        </div>
                    </div>
                `;
            }

            resultsHTML += `
                <div class="result-card">
                    <h3>üìà Utilization Analysis</h3>
                    <div class="result-item">
                        <span>CPU Utilization:</span>
                        <span class="result-value">${calc.actualCpuUtilization.toFixed(1)}%</span>
                    </div>
                    <div class="result-item">
                        <span>Memory Utilization:</span>
                        <span class="result-value">${calc.actualMemoryUtilization.toFixed(1)}%</span>
                    </div>
                    <div class="result-item">
                        <span>Max Utilization Target:</span>
                        <span class="result-value">${calc.maxUtilization}%</span>
                    </div>
                    <div class="result-item">
                        <span>Total Resources + Overhead:</span>
                        <span class="result-value">${calc.totalVcpuWithLogging.toFixed(1)} vCPUs, ${calc.totalMemoryWithLogging.toFixed(1)} GB</span>
                    </div>
                </div>
            `;

            // Growth projections
            if (calc.growthProjections) {
                const currentUtilization = Math.max(calc.actualCpuUtilization, calc.actualMemoryUtilization);
                const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
                const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
                
                resultsHTML += `
                    <div class="growth-chart-container">
                        <h3>üìà Growth Projections</h3>
                        <div class="result-item" style="margin-bottom: 15px;">
                            <span>Current Cluster Utilization:</span>
                            <span class="result-value">${currentUtilization.toFixed(1)}%</span>
                        </div>
                        <div class="result-item" style="margin-bottom: 15px;">
                            <span>Annual Growth Rate:</span>
                            <span class="result-value">${annualGrowthRate}% (${monthlyGrowthRate.toFixed(2)}% monthly)</span>
                        </div>
                        <canvas id="growthChart" width="400" height="200"></canvas>
                    </div>
                    
                    <div class="growth-projections">
                        <div class="projection-card">
                            <h4>üöÄ Monthly Growth Analysis</h4>
                `;
                
                // Show key months
                const keyMonths = calc.growthProjections.filter((_, index) => 
                    index === 0 || index === 3 || index === 6 || index === 12 || index === calc.growthProjections.length - 1
                ).slice(0, 6);
                
                keyMonths.forEach(proj => {
                    resultsHTML += `
                        <div class="projection-item">
                            <span>Month ${proj.month}: ${proj.maxUtilization.toFixed(1)}%</span>
                            <span>${proj.utilizationGrowth > 0 ? '+' : ''}${proj.utilizationGrowth.toFixed(1)}% growth</span>
                        </div>
                    `;
                });
                
                const totalGrowth = ((calc.growthProjections[calc.growthProjections.length - 1].totalInstances / calc.totalInstances - 1) * 100).toFixed(1);
                const finalUtilization = calc.growthProjections[calc.growthProjections.length - 1].maxUtilization;
                
                resultsHTML += `
                        </div>
                        
                        <div class="projection-card">
                            <h4>üìä Growth Summary</h4>
                            <div class="projection-item">
                                <span>Total Instance Growth:</span>
                                <span>${totalGrowth}%</span>
                            </div>
                            <div class="projection-item">
                                <span>Final Utilization:</span>
                                <span>${finalUtilization.toFixed(1)}%</span>
                            </div>
                            <div class="projection-item">
                                <span>Utilization Increase:</span>
                                <span>+${(finalUtilization - currentUtilization).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;

                // Recommendations section - only show the first critical recommendation
                const firstCriticalRecommendation = calc.growthProjections.find(proj => 
                    proj.showRecommendation && (proj.recommendation.includes('URGENT') || proj.recommendation.includes('WARNING') || proj.recommendation.includes('CAUTION'))
                );

                resultsHTML += `
                    <div class="recommendation-card">
                        <h4>üéØ Node Expansion Recommendation</h4>
                `;

                if (firstCriticalRecommendation) {
                    let statusClass = '';
                    if (firstCriticalRecommendation.recommendation.includes('URGENT')) statusClass = 'status-urgent';
                    else if (firstCriticalRecommendation.recommendation.includes('WARNING')) statusClass = 'status-warning';
                    else if (firstCriticalRecommendation.recommendation.includes('CAUTION')) statusClass = 'status-caution';
                    else statusClass = 'status-ok';

                    const nodesNeeded = firstCriticalRecommendation.optimalWorkerNodes - calc.finalWorkerNodes;

                    resultsHTML += `
                        <div class="recommendation-item">
                            <span>Month ${firstCriticalRecommendation.month}: ${firstCriticalRecommendation.maxUtilization.toFixed(1)}% utilization</span>
                            <span class="recommendation-status ${statusClass}">${firstCriticalRecommendation.recommendation}</span>
                        </div>
                        <div class="recommendation-item">
                            <span>Recommended Action:</span>
                            <span class="result-value">Add ${nodesNeeded > 0 ? nodesNeeded : 'additional'} worker node(s)</span>
                        </div>
                        <div class="recommendation-item">
                            <span>Target Instances at that time:</span>
                            <span class="result-value">${firstCriticalRecommendation.totalInstances} instances</span>
                        </div>
                    `;
                } else {
                    resultsHTML += `
                        <div class="recommendation-item">
                            <span>No capacity expansion needed within projection period</span>
                            <span class="recommendation-status status-ok">OK: Current capacity sufficient</span>
                        </div>
                    `;
                }

                resultsHTML += '</div>';
            }

            resultsHTML += (calc.actualCpuUtilization > calc.maxUtilization || calc.actualMemoryUtilization > calc.maxUtilization) ? 
                '<div class="warning">‚ö†Ô∏è Warning: Resource utilization exceeds target threshold. Consider increasing worker node capacity or adding more nodes.</div>' : 
                '<div class="success">‚úÖ Resource allocation looks good! All utilization targets are met.</div>';

            resultsContainer.innerHTML = resultsHTML;

            // Create growth chart if projections exist
            if (calc.growthProjections) {
                setTimeout(() => {
                    createGrowthChart(calc.growthProjections, calc.maxUtilization);
                }, 100);
            }

            // Show export button
            document.getElementById('exportBtn').style.display = 'inline-flex';
        }

        // Initialize
        window.onload = function() {
            initializeWorkloads();
            calculateResources();
        };
    </script>
</body>
</html>
