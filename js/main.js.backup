let selectedLoggingStack = 'elasticsearch';
let workloadCounter = 0;
let workloads = [];
let currentMode = 'capacity';
let selectedSubscriptionType = 'core';
const LOCAL_STORAGE_KEY = 'openShiftSizingCalculatorInputs';

const WORKLOAD_PRESETS = {
    container: { name: 'Typical Container', vcpu: 0.5, memory: 1 },
    vm: { name: 'Typical VM', vcpu: 2, memory: 4 }
};

// Initialize with one default workload
function initializeWorkloads() {
    if (workloads.length === 0) {
        addWorkload();
    }
}

/**
 * @description Handles the selection of the subscription type.
 * @param {string} type - The selected subscription type ('core' or 'socket').
 * @param {HTMLElement} element - The clicked radio option element.
 */
function selectSubscriptionType(type, element) {
    if (element.classList.contains('disabled')) {
        return;
    }
    selectedSubscriptionType = type;
    
    // Update UI selection
    element.parentElement.querySelectorAll('.radio-option').forEach(option => {
        option.classList.remove('selected');
    });
    element.classList.add('selected');
    element.querySelector('input[type="radio"]').checked = true;
    saveInputsToLocalStorage();
}

function selectLoggingStack(stack, element) {
    selectedLoggingStack = stack;
    
    // Update UI
    element.parentElement.querySelectorAll('.radio-option').forEach(option => {
        option.classList.remove('selected');
    });
    element.classList.add('selected');
    
    // Update radio button
    element.querySelector('input[type="radio"]').checked = true;
    saveInputsToLocalStorage();
}

function toggleSocketInput() {
    const customizeSockets = document.getElementById('customizeSockets').checked;
    const socketInput = document.getElementById('socketsPerNode');
    
    socketInput.style.display = customizeSockets ? 'block' : 'none';
    
    if (!customizeSockets) {
        socketInput.value = 2; // Reset to default when hiding
    }
}

function toggleCapacitySocketInput() {
    const customizeSockets = document.getElementById('capacityCustomizeSockets').checked;
    const socketInput = document.getElementById('capacitySocketsPerNode');
    
    socketInput.style.display = customizeSockets ? 'block' : 'none';
    
    if (!customizeSockets) {
        socketInput.value = 2; // Reset to default when hiding
    }
}

function toggleLoggingStorageSection() {
    const content = document.getElementById('storageContent');
    const toggle = document.getElementById('storageToggle');
    
    if (content.classList.contains('active')) {
        content.classList.remove('active');
        toggle.textContent = 'ï¿½';
    } else {
        content.classList.add('active');
        toggle.textContent = 'ï¿½';
    }
}

function toggleGrowthSection() {
    const content = document.getElementById('growthContent');
    const toggle = document.getElementById('growthToggle');
    
    if (content.classList.contains('active')) {
        content.classList.remove('active');
        toggle.textContent = 'ï¿½';
    } else {
        content.classList.add('active');
        toggle.textContent = 'ï¿½';
    }
}

function toggleGrowthInputs() {
    const enableGrowth = document.getElementById('enableGrowth').checked;
    const growthInputs = document.getElementById('growthInputs');
    growthInputs.style.display = enableGrowth ? 'block' : 'none';
}

function addWorkload(workload = null) {
    workloadCounter++;
    const workloadId = `workload-${workloadCounter}`;
    
    const isNew = !workload;
    const type = isNew ? 'container' : workload.type;
    const preset = WORKLOAD_PRESETS[type];
    const name = isNew ? preset.name : workload.name;
    const instances = isNew ? 50 : workload.instances;
    const vcpu = isNew ? preset.vcpu : workload.vcpu;
    const memory = isNew ? preset.memory : workload.memory;
    
    const workloadHTML = `
        <div class="workload-item" id="${workloadId}">
            <button class="remove-workload" onclick="removeWorkload('${workloadId}')" title="Remove workload">ï¿½</button>
            <div class="workload-inputs">
                <div class="workload-field">
                    <label>Workload Name</label>
                    <input type="text" placeholder="e.g., Web Applications" value="${name}" data-field="name" onchange="updateWorkloads()">
                </div>
                <div class="workload-field">
                    <label>Type</label>
                    <select data-field="type" onchange="handleWorkloadTypeChange(this)">
                        <option value="container" ${type === 'container' ? 'selected' : ''}>Container</option>
                        <option value="vm" ${type === 'vm' ? 'selected' : ''}>VM</option>
                    </select>
                </div>
                <div class="workload-field">
                    <label>Instances</label>
                    <input type="number" placeholder="100" value="${instances}" min="1" data-field="instances" onchange="updateWorkloads()">
                </div>
                <div class="workload-field">
                    <label>vCPU/Instance</label>
                    <input type="number" placeholder="0.5" value="${vcpu}" min="0.1" step="0.1" data-field="vcpu" onchange="updateWorkloads()">
                </div>
                <div class="workload-field">
                    <label>Memory/Instance (GB)</label>
                    <input type="number" placeholder="1.0" value="${memory}" min="0.1" step="0.1" data-field="memory" onchange="updateWorkloads()">
                </div>
            </div>
        </div>
    `;
    
    document.getElementById('workloads-container').insertAdjacentHTML('beforeend', workloadHTML);
    if (isNew) {
        updateWorkloads();
    }
}

function handleWorkloadTypeChange(selectElement) {
    const workloadItem = selectElement.closest('.workload-item');
    if (!workloadItem) return;

    const type = selectElement.value;
    const preset = WORKLOAD_PRESETS[type];

    if (preset) {
        workloadItem.querySelector('[data-field="name"]').value = preset.name;
        workloadItem.querySelector('[data-field="vcpu"]').value = preset.vcpu;
        workloadItem.querySelector('[data-field="memory"]').value = preset.memory;
    }

    updateWorkloads();
}

function removeWorkload(workloadId) {
    document.getElementById(workloadId).remove();
    updateWorkloads();
}

function updateWorkloads() {
    workloads = [];
    const workloadElements = document.querySelectorAll('.workload-item');
    
    workloadElements.forEach(element => {
        const workload = {
            name: element.querySelector('[data-field="name"]').value || 'Unnamed Workload',
            type: element.querySelector('[data-field="type"]').value,
            instances: parseInt(element.querySelector('[data-field="instances"]').value) || 0,
            vcpu: parseFloat(element.querySelector('[data-field="vcpu"]').value) || 0,
            memory: parseFloat(element.querySelector('[data-field="memory"]').value) || 0
        };
        workloads.push(workload);
    });
    checkSubscriptionForVmWorkloads();
    saveInputsToLocalStorage();
}

function checkSubscriptionForVmWorkloads() {
    const hasVmWorkload = workloads.some(w => w.type === 'vm');
    const subscriptionSelector = document.getElementById('subscription-type-selector');
    const coreOption = subscriptionSelector.querySelector('div[onclick*="\'core\'"]');
    const socketOption = subscriptionSelector.querySelector('div[onclick*="\'socket\'"]');

    // Remove existing warning message if any
    const existingWarning = document.getElementById('vm-subscription-warning');
    if (existingWarning) {
        existingWarning.remove();
    }

    // Use classList to enable/disable the core option
    coreOption.classList.toggle('disabled', hasVmWorkload);
    coreOption.querySelector('input').disabled = hasVmWorkload;

    if (hasVmWorkload) {
        // Force selection to socket-based
        selectSubscriptionType('socket', socketOption);

        // Add a warning message
        const warningHTML = `
            <div id="vm-subscription-warning" class="warning" style="margin-top: 15px;">
                =ï¿½ OpenShift Virtualization (VMs) requires a Bare-metal (Socket-based) subscription. The subscription type has been automatically selected.
            </div>
        `;
        subscriptionSelector.insertAdjacentHTML('afterend', warningHTML);
    }
}

/**
 * @description Calculates the required OpenShift subscriptions based on the cluster size and subscription model.
 * @param {string} type - The subscription type ('core' or 'socket').
 * @param {number} billableNodes - The number of nodes that count towards subscription (i.e., worker nodes).
 * @param {number} cpuCoresPerNode - The number of physical CPU cores per node.
 * @param {number} socketsPerNode - The number of physical sockets per node.
 * @returns {object} An object containing the subscription calculation details.
 */
function calculateSubscriptions(type, billableNodes, cpuCoresPerNode, socketsPerNode) {
    const totalPhysicalCores = billableNodes * cpuCoresPerNode;
    const totalSockets = billableNodes * socketsPerNode;
    let subscriptions = 0;
    let calculationMethod = '';

    if (type === 'core') {
        // Core-based: 1 subscription per 2 physical cores.
        subscriptions = Math.ceil(totalPhysicalCores / 2);
        calculationMethod = `Core-based: ${totalPhysicalCores} total billable cores / 2 cores per subscription.`;
    } else if (type === 'socket') {
        // Bare-metal (Socket-based): The greater of (sockets/2) or (cores/128).
        const subsBySockets = Math.ceil(totalSockets / 2);
        const subsByCores = Math.ceil(totalPhysicalCores / 128);
        subscriptions = Math.max(subsBySockets, subsByCores);
        
        if (subsByCores > subsBySockets) {
            calculationMethod = `Bare-metal (Core-limited): ${totalPhysicalCores} total billable cores / 128 cores per subscription.`;
        } else {
            calculationMethod = `Bare-metal (Socket-limited): ${totalSockets} total billable sockets / 2 sockets per subscription.`;
        }
    }

    return {
        count: subscriptions,
        type: type === 'core' ? 'Core-based' : 'Bare-metal (Socket-based)',
        totalPhysicalCores,
        totalSockets,
        calculationMethod
    };
}

function calculateCpuReservation(totalCpuCores) {
    let reservation = 0;
    
    if (totalCpuCores >= 1) {
        reservation += 1 * 0.06; // First CPU: 6%
    }
    if (totalCpuCores >= 2) {
        reservation += 1 * 0.01; // Second CPU: 1%
    }
    if (totalCpuCores >= 3) {
        let cores3to4 = Math.min(totalCpuCores - 2, 2);
        reservation += cores3to4 * 0.005; // 3rd-4th CPU: 0.5%
    }
    if (totalCpuCores > 4) {
        let remainingCores = totalCpuCores - 4;
        reservation += remainingCores * 0.0025; // Remaining: 0.25%
    }
    
    return reservation;
}

function calculateMemoryReservation(totalMemoryGB) {
    let reservation = 0;
    
    // 25% of first 4 GB
    let first4GB = Math.min(totalMemoryGB, 4);
    reservation += first4GB * 0.25;
    
    // 20% of next 4 GB (GB 4-8)
    if (totalMemoryGB > 4) {
        let next4GB = Math.min(totalMemoryGB - 4, 4);
        reservation += next4GB * 0.20;
    }
    
    // 10% of next 8 GB (GB 8-16)
    if (totalMemoryGB > 8) {
        let next8GB = Math.min(totalMemoryGB - 8, 8);
        reservation += next8GB * 0.10;
    }
    
    // 6% of next 112 GB (GB 16-128)
    if (totalMemoryGB > 16) {
        let next112GB = Math.min(totalMemoryGB - 16, 112);
        reservation += next112GB * 0.06;
    }
    
    // 2% of remaining memory (GB 128+)
    if (totalMemoryGB > 128) {
        let remaining = totalMemoryGB - 128;
        reservation += remaining * 0.02;
    }
    
    return reservation;
}

function calculateLogStorageRequirements() {
    const logVolumePerPod = parseFloat(document.getElementById('logVolumePerPod').value);
    const retentionDays = parseInt(document.getElementById('logRetentionDays').value);
    const compressionRatio = parseFloat(document.getElementById('compressionRatio').value);
    const replicationFactor = parseInt(document.getElementById('replicationFactor').value);

    // Calculate total pods across all workloads
    const totalPods = workloads.reduce((sum, workload) => sum + workload.instances, 0);
    
    // Calculate raw log volume
    const dailyRawLogVolume = totalPods * logVolumePerPod; // MB/day
    const totalRawLogVolume = dailyRawLogVolume * retentionDays; // MB total
    
    // Apply compression
    const compressedLogVolume = totalRawLogVolume / compressionRatio;
    
    // Add infrastructure logs (estimated at 20% of application logs)
    const infraLogVolume = compressedLogVolume * 0.2;
    const totalLogVolume = compressedLogVolume + infraLogVolume;
    
    // Apply replication factor (for Elasticsearch)
    let storageWithReplication = totalLogVolume;
    if (selectedLoggingStack === 'elasticsearch') {
        storageWithReplication = totalLogVolume * replicationFactor;
    }
    
    // Add safety margin (20%)
    const finalStorageRequirement = storageWithReplication * 1.2;
    
    // Convert to GB
    const storageRequirementGB = finalStorageRequirement / 1024;
    
    return {
        totalPods,
        dailyRawLogVolumeMB: dailyRawLogVolume,
        totalRawLogVolumeMB: totalRawLogVolume,
        compressedLogVolumeMB: compressedLogVolume,
        infraLogVolumeMB: infraLogVolume,
        totalLogVolumeMB: totalLogVolume,
        storageWithReplicationMB: storageWithReplication,
        finalStorageRequirementGB: storageRequirementGB,
        retentionDays,
        compressionRatio,
        replicationFactor
    };
}

function getMasterNodeRequirements() {
    // Master node resource requirements (per master)
    return {
        cpu: 2, // 2 vCPUs per master
        memory: 8 // 8 GB per master
    };
}

function getLoggingOverhead(stack, workerNodes) {
    if (stack === 'elasticsearch') {
        return {
            memoryPerNode: 0.786, // 786Mi in GB
            cpuPerNode: 0.25, // 250m in cores
            totalMemory: workerNodes * 0.786,
            totalCpu: workerNodes * 0.25
        };
    } else {
        return {
            memoryPerNode: 2.05, // 2Gi + 50Mi in GB
            cpuPerNode: 0.25, // 250m in cores
            totalMemory: workerNodes * 2.05,
            totalCpu: workerNodes * 0.25
        };
    }
}

function getInfrastructureRequirements(stack, clusterSize) {
    const loggingInfra = {
        elasticsearch: {
            small: { memory: 49, cpu: 10, storage: 800 },
            medium: { memory: 125, cpu: 15, storage: 2000 },
            large: { memory: 280, cpu: 30, storage: 4000 }
        },
        loki: {
            small: { memory: 16, cpu: 10, storage: 300 },
            medium: { memory: 25, cpu: 18, storage: 600 },
            large: { memory: 47, cpu: 35, storage: 1200 }
        }
    };

    const monitoring = {
        small: { memory: 10.6, cpu: 5, storage: 200 },
        medium: { memory: 25, cpu: 8, storage: 400 },
        large: { memory: 50, cpu: 15, storage: 800 }
    };

    const sizeCategory = getInfrastructureSizeCategory(stack, clusterSize);
    const logging = loggingInfra[stack][sizeCategory];
    const mon = monitoring[sizeCategory];
    return { totalMemory: logging.memory + mon.memory, totalCpu: logging.cpu + mon.cpu, totalStorage: logging.storage + mon.storage, loggingMemory: logging.memory, monitoringMemory: mon.memory };
}

function getInfrastructureSizeCategory(stack, clusterSize) {
    const loggingInfra = {
        elasticsearch: {
            small: { memory: 49, cpu: 10, storage: 800 },
            medium: { memory: 125, cpu: 15, storage: 2000 },
            large: { memory: 280, cpu: 30, storage: 4000 }
        },
        loki: {
            small: { memory: 16, cpu: 10, storage: 300 },
            medium: { memory: 25, cpu: 18, storage: 600 },
            large: { memory: 47, cpu: 35, storage: 1200 }
        }
    };

    const monitoring = {
        small: { memory: 10.6, cpu: 5, storage: 200 },
        medium: { memory: 25, cpu: 8, storage: 400 },
        large: { memory: 50, cpu: 15, storage: 800 }
    };

    let sizeCategory;
    if (clusterSize < 50) sizeCategory = 'small';
    else if (clusterSize < 250) sizeCategory = 'medium';
    else sizeCategory = 'large';

    return sizeCategory;
}

function calculateGrowthProjections(baseWorkloads, annualGrowthRate, months, usableVcpuPerNode, usableMemoryPerNode, maxUtilization, currentWorkerNodes) {
    const projections = [];
    const maxUtilizationPercent = maxUtilization * 100;

    // Derive total available resources per node for accurate utilization reporting
    const availableVcpuPerNode = usableVcpuPerNode / maxUtilization;
    const availableMemoryPerNode = usableMemoryPerNode / maxUtilization;
    
    // Convert annual growth rate to monthly growth rate
    const monthlyGrowthRate = Math.pow(1 + (annualGrowthRate / 100), 1/12) - 1;
    
    let firstUrgentMonth = null;
    let firstWarningMonth = null;
    let firstCautionMonth = null;

    let workerNodesForMonth = currentWorkerNodes; // Start with the initial node count
    
    for (let month = 0; month <= months; month++) {
        const growthFactor = month === 0 ? 1 : Math.pow(1 + monthlyGrowthRate, month);
        
        const projectedWorkloads = baseWorkloads.map(workload => ({
            ...workload,
            instances: Math.ceil(workload.instances * growthFactor)
        }));
        
        const totalInstances = projectedWorkloads.reduce((sum, w) => sum + w.instances, 0);
        const totalVcpu = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.vcpu), 0);
        const totalMemory = projectedWorkloads.reduce((sum, w) => sum + (w.instances * w.memory), 0);

        // Calculate utilization based on the nodes available at the start of the month
        const totalAvailableVcpu = workerNodesForMonth * availableVcpuPerNode;
        const totalAvailableMemory = workerNodesForMonth * availableMemoryPerNode;

        const cpuUtilization = (totalVcpu / totalAvailableVcpu) * 100;
        const memoryUtilization = (totalMemory / totalAvailableMemory) * 100;
        const maxCurrentUtilization = Math.max(cpuUtilization, memoryUtilization);
        
        // Determine if expansion is needed for the *next* month
        const needsExpansion = maxCurrentUtilization > maxUtilizationPercent;
        let optimalNodesForNextMonth = workerNodesForMonth;
        if (needsExpansion) {
            const nodesForCpu = Math.ceil(totalVcpu / usableVcpuPerNode);
            const nodesForMemory = Math.ceil(totalMemory / usableMemoryPerNode);
            optimalNodesForNextMonth = Math.max(nodesForCpu, nodesForMemory, 3);
        }
        
        // Calculate growth from previous month
        let utilizationGrowth = 0;
        if (month > 0 && projections.length > 0) {
            utilizationGrowth = maxCurrentUtilization - projections[projections.length - 1].maxUtilization;
        }
        
        // Recommendation logic - only set once for the first occurrence
        let recommendation = '';
        let showRecommendation = false;
        
        if (maxCurrentUtilization > maxUtilizationPercent + 5) {
            recommendation = 'URGENT: Add nodes immediately';
            if (firstUrgentMonth === null) {
                firstUrgentMonth = month;
                showRecommendation = true;
            }
        } else if (maxCurrentUtilization > maxUtilizationPercent) {
            recommendation = 'WARNING: Plan node expansion';
            if (firstWarningMonth === null && firstUrgentMonth === null) {
                firstWarningMonth = month;
                showRecommendation = true;
            }
        } else if (maxCurrentUtilization > maxUtilizationPercent - 10) {
            recommendation = 'CAUTION: Monitor closely';
            if (firstCautionMonth === null && firstWarningMonth === null && firstUrgentMonth === null) {
                firstCautionMonth = month;
                showRecommendation = true;
            }
        } else {
            recommendation = 'OK: Capacity sufficient';
        }
        
        projections.push({
            month: month,
            workloads: projectedWorkloads,
            totalInstances: totalInstances,
            totalVcpu: totalVcpu,
            totalMemory: totalMemory,
            workerNodesInMonth: workerNodesForMonth,
            recommendedNodesForNextMonth: optimalNodesForNextMonth,
            cpuUtilization: cpuUtilization,
            memoryUtilization: memoryUtilization,
            maxUtilization: maxCurrentUtilization,
            utilizationGrowth: utilizationGrowth,
            needsExpansion: needsExpansion,
            recommendation: recommendation,
            showRecommendation: showRecommendation,
            growthFactor: growthFactor,
            monthlyGrowthRate: monthlyGrowthRate * 100
        });

        // Set the node count for the next iteration
        workerNodesForMonth = optimalNodesForNextMonth;
    }
    
    return projections;
}

function exportToExcel() {
    if (!window.lastCalculationResults) {
        alert('Please calculate resources first before exporting');
        return;
    }

    const calc = window.lastCalculationResults;
    
    // Create workbook
    const wb = XLSX.utils.book_new();
    
    // Summary sheet
    const summaryData = [
        ['OpenShift Resource Planning Calculator'],
        ['Generated on:', new Date().toLocaleString()],
        [''],
        ['Cluster Summary'],
        ['Worker Nodes Required:', calc.finalWorkerNodes],
        ['Master Nodes:', calc.mergeMasters ? '0 (merged)' : calc.masterNodes],
        ['Dedicated Infrastructure:', calc.infraReqs.totalCpu > 0 ? 'User-defined resource pool' : 'None'],
        ['Total Cluster Size:', calc.totalClusterNodes],
        ['Configuration:', calc.mergeMasters ? 'Compact cluster (Masters merged)' : 'Dedicated nodes'],
        [''],
        ['Workload Requirements'],
        ['Total Application Instances:', calc.totalInstances],
        ['Total vCPU Needed:', calc.totalVcpuNeeded.toFixed(1)],
        ['Total Memory Needed (GB):', calc.totalMemoryNeeded.toFixed(1)],
        ['Logging Stack:', calc.selectedLoggingStack === 'elasticsearch' ? 'Elasticsearch' : 'LokiStack'],
        [''],
        ['Worker Node Capacity'],
        ['Physical CPU Cores:', calc.cpuCores],
        ['Total vCPUs per Node:', calc.totalVcpuPerNode],
        ['Available vCPUs (after OS):', calc.availableVcpuPerNode.toFixed(2)],
        ['Available Memory (after OS) (GB):', calc.availableMemoryPerNode.toFixed(1)],
        [''],
        ['Utilization Analysis'],
        ['CPU Utilization (%):', calc.actualCpuUtilization.toFixed(1)],
        ['Memory Utilization (%):', calc.actualMemoryUtilization.toFixed(1)],
        ['Max Utilization Target (%):', calc.maxUtilization],
        [''],
        ['Subscription Requirements'],
        ['Model:', calc.subscriptionInfo.type],
        ['Billable Nodes (Workers):', calc.finalWorkerNodes],
        ['Total Billable Cores:', calc.subscriptionInfo.totalPhysicalCores],
        ...(calc.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? 
            [['Total Billable Sockets:', calc.subscriptionInfo.totalSockets]] : 
            []),
        ['Required Subscriptions:', calc.subscriptionInfo.count],
        ['Calculation:', calc.subscriptionInfo.calculationMethod],
        [''],
        ['Calculated Infrastructure Requirements'],
        ['Total Infra CPU (Cores):', calc.infraReqs.totalCpu.toFixed(1)],
        ['Total Infra Memory (GB):', calc.infraReqs.totalMemory.toFixed(1)],
        ['Total Infra Storage (GB):', calc.infraReqs.totalStorage.toFixed(1)],
        [''],
        ['Log Storage Requirements'],
        ['Total Pods Generating Logs:', calc.logStorage.totalPods],
        ['Daily Raw Log Volume (GB):', (calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)],
        ['Total Storage Required (GB):', calc.logStorage.finalStorageRequirementGB.toFixed(1)],
        ['Retention Period (days):', calc.logStorage.retentionDays],
        ['Compression Ratio:', calc.logStorage.compressionRatio + ':1']
    ];
    
    const summaryWs = XLSX.utils.aoa_to_sheet(summaryData);
    XLSX.utils.book_append_sheet(wb, summaryWs, 'Summary');
    
    // Workloads sheet
    const workloadData = [
        ['Workload Breakdown'],
        ['Name', 'Instances', 'vCPU per Instance', 'Memory per Instance (GB)', 'Total vCPU', 'Total Memory (GB)']
    ];
    
    calc.workloads.forEach(workload => {
        workloadData.push([
            workload.name,
            workload.instances,
            workload.vcpu,
            workload.memory,
            (workload.instances * workload.vcpu).toFixed(1),
            (workload.instances * workload.memory).toFixed(1)
        ]);
    });
    
    const workloadWs = XLSX.utils.aoa_to_sheet(workloadData);
    XLSX.utils.book_append_sheet(wb, workloadWs, 'Workloads');
    
    // Growth projections sheet (if available)
    if (calc.growthProjections) {
        const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
        const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
        
        const growthData = [
            ['Growth Projections'],
            ['Annual Growth Rate (%):', annualGrowthRate],
            ['Equivalent Monthly Growth Rate (%):', monthlyGrowthRate.toFixed(3)],
            [''],
            ['Month', 'Total Instances', 'Total vCPU', 'Total Memory (GB)', 'Nodes in Month', 'CPU Utilization (%)', 'Memory Utilization (%)', 'Max Utilization (%)', 'Utilization Growth (%)', 'Recommendation', 'Show Alert']
        ];
        
        calc.growthProjections.forEach(proj => {
            growthData.push([
                proj.month,
                proj.totalInstances,
                proj.totalVcpu.toFixed(1),
                proj.totalMemory.toFixed(1),
                proj.workerNodesInMonth,
                proj.cpuUtilization.toFixed(1),
                proj.memoryUtilization.toFixed(1),
                proj.maxUtilization.toFixed(1),
                proj.utilizationGrowth.toFixed(1),
                proj.recommendation,
                proj.showRecommendation ? 'YES' : 'NO'
            ]);
        });
        
        const growthWs = XLSX.utils.aoa_to_sheet(growthData);
        XLSX.utils.book_append_sheet(wb, growthWs, 'Growth Projections');
    }
    
    // Save file
    const fileName = `OpenShift_Resource_Plan_${new Date().toISOString().split('T')[0]}.xlsx`;
    XLSX.writeFile(wb, fileName);
}

function createGrowthChart(projections, maxUtilizationThreshold) {
    const canvas = document.getElementById('growthChart');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Destroy existing chart if it exists
    if (window.growthChartInstance) {
        window.growthChartInstance.destroy();
    }
    
    // Create threshold line data
    const thresholdData = projections.map(() => maxUtilizationThreshold);
    const warningThresholdData = projections.map(() => maxUtilizationThreshold + 10);
    
    window.growthChartInstance = new Chart(ctx, {
        type: 'line',
        data: {
            labels: projections.map(p => `Month ${p.month}`),
            datasets: [
                {
                    label: 'Cluster Utilization (%)',
                    data: projections.map(p => p.maxUtilization),
                    borderColor: '#ee0979',
                    backgroundColor: 'rgba(238, 9, 121, 0.1)',
                    tension: 0.4,
                    fill: false,
                    pointRadius: 5,
                    pointHoverRadius: 8
                },
                {
                    label: 'Target Threshold',
                    data: thresholdData,
                    borderColor: '#28a745',
                    backgroundColor: 'transparent',
                    borderDash: [5, 5],
                    tension: 0,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0
                },
                {
                    label: 'Warning Threshold',
                    data: warningThresholdData,
                    borderColor: '#ffc107',
                    backgroundColor: 'transparent',
                    borderDash: [10, 5],
                    tension: 0,
                    fill: false,
                    pointRadius: 0,
                    pointHoverRadius: 0
                }
            ]
        },
        options: {
            responsive: true,
            interaction: {
                mode: 'index',
                intersect: false,
            },
            scales: {
                x: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Timeline'
                    }
                },
                y: {
                    display: true,
                    title: {
                        display: true,
                        text: 'Utilization (%)'
                    },
                    min: 0,
                    max: Math.max(100, Math.max(...projections.map(p => p.maxUtilization)) + 10)
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: 'Growth Projection: Cluster Utilization Over Time'
                },
                legend: {
                    display: true
                },
                tooltip: {
                    callbacks: {
                        afterBody: function(context) {
                            if (context[0].datasetIndex === 0) {
                                const projection = projections[context[0].dataIndex];
                                return [
                                    `Instances: ${projection.totalInstances}`,
                                    `vCPU Usage: ${projection.totalVcpu.toFixed(1)}`,
                                    `Memory Usage: ${projection.totalMemory.toFixed(1)} GB`,
                                    `Recommendation: ${projection.recommendation}`
                                ];
                            }
                            return null;
                        }
                    }
                }
            }
        }
    });
}

function calculateResources() {
    // Update workloads from UI
    updateWorkloads();
    
    if (workloads.length === 0) {
        alert('Please add at least one workload type');
        return;
    }

    // Calculate total workload requirements
    const totalInstances = workloads.reduce((sum, workload) => sum + workload.instances, 0);
    const totalVcpuNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.vcpu), 0);
    const totalMemoryNeeded = workloads.reduce((sum, workload) => sum + (workload.instances * workload.memory), 0);

    // Calculate log storage requirements
    const logStorage = calculateLogStorageRequirements();

    // Get worker node specifications
    const cpuCores = parseInt(document.getElementById('cpuCores').value);
    const cpuToVcpuRatio = parseFloat(document.getElementById('cpuToVcpuRatio').value);
    const socketsPerNode = parseInt(document.getElementById('socketsPerNode').value);
    const memoryPerNode = parseInt(document.getElementById('memoryPerNode').value);
    const maxUtilization = parseInt(document.getElementById('maxUtilization').value) / 100;
    
    // Get merge options
    const mergeMasters = document.getElementById('mergeMasters').checked;
    
    // Calculate worker node capacity
    const totalVcpuPerNode = cpuCores * cpuToVcpuRatio;
    
    // Calculate OpenShift reservations
    const cpuReservation = calculateCpuReservation(cpuCores);
    const memoryReservation = calculateMemoryReservation(memoryPerNode);
    
    // Available resources after OpenShift reservations
    let availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
    let availableMemoryPerNode = memoryPerNode - memoryReservation;
    
    // Account for master node requirements if merged
    let masterOverhead = { cpu: 0, memory: 0 };
    if (mergeMasters) {
        const masterReqs = getMasterNodeRequirements();
        masterOverhead.cpu = masterReqs.cpu;
        masterOverhead.memory = masterReqs.memory;
        availableVcpuPerNode -= masterReqs.cpu;
        availableMemoryPerNode -= masterReqs.memory;
    }
    
    // Calculate usable resources considering max utilization
    const usableVcpuPerNode = availableVcpuPerNode * maxUtilization;
    const usableMemoryPerNode = availableMemoryPerNode * maxUtilization;
    
    // Calculate worker nodes needed (before logging overhead)
    const nodesForCpu = Math.ceil(totalVcpuNeeded / usableVcpuPerNode);
    const nodesForMemory = Math.ceil(totalMemoryNeeded / usableMemoryPerNode);
    let baseWorkerNodes = Math.max(nodesForCpu, nodesForMemory);
    
    // For merged masters, ensure minimum 3 nodes for HA
    if (mergeMasters) {
        baseWorkerNodes = Math.max(baseWorkerNodes, 3);
    }
    
    // Account for logging overhead and recalculate
    let finalWorkerNodes = baseWorkerNodes;
    let iterations = 0;
    const maxIterations = 10;
    let infraReqs = {};
    
    while (iterations < maxIterations) {
        const loggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
        
        // Calculate infra requirements based on current estimated cluster size
        const currentClusterSize = (mergeMasters ? 0 : 3) + finalWorkerNodes;
        infraReqs = getInfrastructureRequirements(selectedLoggingStack, currentClusterSize);
        
        // Total requirements including logging and infra overhead
        let totalVcpuWithLogging = totalVcpuNeeded + loggingOverhead.totalCpu + infraReqs.totalCpu;
        let totalMemoryWithLogging = totalMemoryNeeded + loggingOverhead.totalMemory + infraReqs.totalMemory;
        
        // Calculate new worker node requirements
        const newNodesForCpu = Math.ceil(totalVcpuWithLogging / usableVcpuPerNode);
        const newNodesForMemory = Math.ceil(totalMemoryWithLogging / usableMemoryPerNode);
        let newWorkerNodes = Math.max(newNodesForCpu, newNodesForMemory);
        
        // Ensure minimum nodes for merged configurations
        if (mergeMasters) {
            newWorkerNodes = Math.max(newWorkerNodes, 3);
        }
        
        if (newWorkerNodes === finalWorkerNodes) {
            break; // Converged
        }
        
        finalWorkerNodes = newWorkerNodes;
        iterations++;
    }

    // Calculate final cluster size
    const masterNodes = mergeMasters ? 0 : 3;
    // Infra nodes are now explicitly defined by user input, not calculated as part of the primary cluster node count.
    // The 'infraNodes' variable here will represent the count of *dedicated* infra nodes if the user specifies them,
    // but for the purpose of 'totalClusterNodes' (which influences logging/monitoring sizing), we only count masters and workers.
    const totalClusterNodes = masterNodes + finalWorkerNodes;
    
    // Calculate subscription requirements based on worker nodes only
    const subscriptionInfo = calculateSubscriptions(selectedSubscriptionType, finalWorkerNodes, cpuCores, socketsPerNode);

    // Recalculate final infra requirements based on the converged node count
    const finalInfraReqs = getInfrastructureRequirements(selectedLoggingStack, totalClusterNodes);

    // Note: getLoggingOverhead already uses workerNodes, not totalClusterNodes for per-node overhead
    const finalLoggingOverhead = getLoggingOverhead(selectedLoggingStack, finalWorkerNodes);
    
    // Calculate final overhead
    const finalInfraOverhead = { cpu: finalInfraReqs.totalCpu, memory: finalInfraReqs.totalMemory };
    // Calculate actual utilization
    let totalVcpuWithLogging = totalVcpuNeeded + finalLoggingOverhead.totalCpu + finalInfraOverhead.cpu;
    let totalMemoryWithLogging = totalMemoryNeeded + finalLoggingOverhead.totalMemory + finalInfraOverhead.memory;
    
    const actualCpuUtilization = (totalVcpuWithLogging / (finalWorkerNodes * availableVcpuPerNode)) * 100;
    const actualMemoryUtilization = (totalMemoryWithLogging / (finalWorkerNodes * availableMemoryPerNode)) * 100;

    // Growth projections
    let growthProjections = null;
    if (document.getElementById('enableGrowth').checked) {
        const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
        const projectionMonths = parseInt(document.getElementById('projectionMonths').value);
        
        growthProjections = calculateGrowthProjections(
            workloads, 
            annualGrowthRate, 
            projectionMonths, 
            usableVcpuPerNode, 
            usableMemoryPerNode, 
            maxUtilization,
            finalWorkerNodes
        );
    }

    // Store results for export
    window.lastCalculationResults = {
        workloads,
        totalInstances,
        totalVcpuNeeded,
        totalMemoryNeeded,
        logStorage,
        cpuCores,
        cpuToVcpuRatio,
        socketsPerNode,
        totalVcpuPerNode,
        memoryPerNode,
        cpuReservation,
        memoryReservation,
        availableVcpuPerNode: availableVcpuPerNode + (mergeMasters ? masterOverhead.cpu : 0),
        availableMemoryPerNode: availableMemoryPerNode + (mergeMasters ? masterOverhead.memory : 0),
        usableVcpuPerNode,
        usableMemoryPerNode,
        finalWorkerNodes,
        masterNodes,
        infraNodes: 0, // Dedicated infra nodes are now a resource pool, not counted in this 'nodes' variable
        totalClusterNodes, // This is the final converged infra requirements
        infraReqs: finalInfraReqs,
        finalLoggingOverhead,
        actualCpuUtilization,
        actualMemoryUtilization,
        maxUtilization: maxUtilization * 100,
        totalVcpuWithLogging,
        totalMemoryWithLogging,
        mergeMasters,
        masterOverhead,
        finalInfraOverhead, // This is now correctly defined and passed
        growthProjections,
        subscriptionInfo
    };

    // Display results
    displayResults(window.lastCalculationResults);
}

function displayResults(calc) {
    const resultsContainer = document.getElementById('results-container');
    
    const isOverutilized = calc.actualCpuUtilization > calc.maxUtilization || calc.actualMemoryUtilization > calc.maxUtilization;
    const utilizationStatusMessage = isOverutilized ? 
        '<div class="warning">ï¿½ Warning: Resource utilization exceeds target. Consider adding more nodes or using larger ones.</div>' : 
        '<div class="success"> Allocation looks good! All utilization targets are met.</div>';

    let resultsHTML = `
        <div class="result-card" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">
            <h3>= Key Recommendations</h3>
            <div class="result-item">
                <span><span class="status-icon">#ï¿½</span>Worker Nodes Required:</span>
                <span class="result-value" style="font-size: 1.5rem;">${calc.finalWorkerNodes}</span>
            </div>
             <div class="result-item">
                <span><span class="status-icon"><ï¿½</span>Required Subscriptions:</span>
                <span class="result-value" style="font-size: 1.5rem;">${calc.subscriptionInfo.count}</span>
            </div>
            <div class="result-item">
                <span><span class="status-icon">${isOverutilized ? 'ï¿½' : ''}</span>Cluster Utilization:</span>
                <span class="result-value">CPU: ${calc.actualCpuUtilization.toFixed(1)}% | Mem: ${calc.actualMemoryUtilization.toFixed(1)}%</span>
            </div>
            ${utilizationStatusMessage}
        </div>

        <div class="result-card">
            <h3><ï¿½ Cluster Profile & Node Configuration</h3>
            <div class="result-item"><span>Total Worker Nodes:</span><span class="result-value">${calc.finalWorkerNodes}</span></div>
            <div class="result-item"><span>Total Master Nodes:</span><span class="result-value">${calc.mergeMasters ? '0 (merged)' : calc.masterNodes}</span></div>
            <div class="result-item"><span>Configuration:</span><span class="result-value">${calc.mergeMasters ? 'Compact' : 'Dedicated Masters'}</span></div>
            
            <div class="breakdown-section" style="margin-top: 20px; background: rgba(255,255,255,0.1);">
                <div class="breakdown-title" style="color: white;">Single Worker Node Profile</div>
                <div class="breakdown-item"><span>Physical Capacity</span><span>${calc.cpuCores} Cores / ${calc.memoryPerNode} GB RAM</span></div>
                <div class="breakdown-item"><span>(-) OS/System Reservation</span><span>-${calc.cpuReservation.toFixed(2)} Cores / -${calc.memoryReservation.toFixed(1)} GB RAM</span></div>
                ${calc.mergeMasters ? `<div class="breakdown-item"><span>(-) Master Services Overhead</span><span>-${calc.masterOverhead.cpu} vCPUs / -${calc.masterOverhead.memory} GB RAM</span></div>` : ''}
                <div class="breakdown-item"><span>(-) Logging Agent Overhead</span><span>-${calc.finalLoggingOverhead.cpuPerNode.toFixed(2)} vCPUs / -${calc.finalLoggingOverhead.memoryPerNode.toFixed(2)} GB RAM</span></div>
                <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold;"><span>(=) Available for Workloads</span><span>${(calc.availableVcpuPerNode + (calc.mergeMasters ? calc.masterOverhead.cpu : 0)).toFixed(2)} vCPUs / ${(calc.availableMemoryPerNode + (calc.mergeMasters ? calc.masterOverhead.memory : 0)).toFixed(1)} GB RAM</span></div>
                <div class="breakdown-item"><span>(ï¿½) Max Utilization Target</span><span>${calc.maxUtilization}%</span></div>
                <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold; background: rgba(0,0,0,0.2);"><span>(=) Usable Capacity per Node</span><span>${calc.usableVcpuPerNode.toFixed(2)} vCPUs / ${calc.usableMemoryPerNode.toFixed(1)} GB RAM</span></div>
            </div>
        </div>

        <div class="result-card">
            <h3>=ï¿½ Total Resource Demand</h3>
            <div class="breakdown-section" style="background: rgba(255,255,255,0.1);">
                <div class="breakdown-title" style="color: white;">Application Workloads</div>
                ${calc.workloads.map(w => `
                    <div class="breakdown-item">
                        <span>${w.name} (${w.instances} x ${w.type})</span>
                        <span>${(w.instances * w.vcpu).toFixed(1)} vCPUs / ${(w.instances * w.memory).toFixed(1)} GB</span>
                    </div>
                `).join('')}
                <div class="breakdown-item" style="border-top: 2px solid white; font-weight: bold;">
                    <span>Subtotal:</span>
                    <span>${calc.totalVcpuNeeded.toFixed(1)} vCPUs / ${calc.totalMemoryNeeded.toFixed(1)} GB</span>
                </div>
            </div>
            <div class="breakdown-section" style="margin-top: 15px; background: rgba(255,255,255,0.1);">
                <div class="breakdown-title" style="color: white;">Cluster Services Overhead</div>
                <div class="breakdown-item"><span>Logging, Monitoring, etc.</span><span>${calc.finalInfraOverhead.cpu.toFixed(1)} vCPUs / ${calc.finalInfraOverhead.memory.toFixed(1)} GB</span></div>
            </div>
             <div class="result-item" style="margin-top: 15px;">
                <span><strong>Total Required Capacity:</strong></span>
                <span class="result-value">${calc.totalVcpuWithLogging.toFixed(1)} vCPUs / ${calc.totalMemoryWithLogging.toFixed(1)} GB</span>
            </div>
        </div>

        <div class="result-card">
            <h3><ï¿½ OpenShift Subscription Estimate</h3>
            <div class="result-item">
                <span>Subscription Model:</span>
                <span class="result-value">${calc.subscriptionInfo.type}</span>
            </div>
            <div class="result-item">
                <span>Total Billable Physical Cores (on ${calc.finalWorkerNodes} worker nodes):</span>
                <span class="result-value">${calc.subscriptionInfo.totalPhysicalCores} cores</span>
            </div>
            ${calc.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
            <div class="result-item">
                <span>Total Billable Sockets (on ${calc.finalWorkerNodes} worker nodes):</span>
                <span class="result-value">${calc.subscriptionInfo.totalSockets} sockets</span>
            </div>
            ` : ''}
            <div class="result-item">
                <span><strong>Required Subscriptions:</strong></span>
                <span class="result-value" style="font-size: 1.5rem;">${calc.subscriptionInfo.count}</span>
            </div>
            <div class="warning" style="margin-top: 15px; padding: 10px; text-align: center; background: rgba(0,0,0,0.2);">
                =ï¿½ <strong>Calculation:</strong> ${calc.subscriptionInfo.calculationMethod}
            </div>
        </div>`;

    resultsHTML += `
        <div class="storage-breakdown">
            <h3>=ï¿½ Log Storage Requirements</h3>
            <div class="result-item">
                <span>Total Pods Generating Logs:</span>
                <span class="result-value">${calc.logStorage.totalPods}</span>
            </div>
            <div class="result-item">
                <span>Daily Raw Log Volume:</span>
                <span class="result-value">${(calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)} GB/day</span>
            </div>
            <div class="result-item">
                <span>Total Storage Required (incl. retention, compression):</span>
                <span class="result-value">${calc.logStorage.finalStorageRequirementGB.toFixed(1)} GB</span>
            </div>
            ${selectedLoggingStack === 'elasticsearch' ? `
            <div class="result-item">
                <span>Replication Factor:</span>
                <span class="result-value">${calc.logStorage.replicationFactor}x</span>
            </div>
            ` : ''}
        </div>
    `;


    // Growth projections
    if (calc.growthProjections) {
        const currentUtilization = Math.max(calc.actualCpuUtilization, calc.actualMemoryUtilization);
        const annualGrowthRate = parseFloat(document.getElementById('growthRate').value);
        const monthlyGrowthRate = calc.growthProjections[1] ? calc.growthProjections[1].monthlyGrowthRate : 0;
        
        resultsHTML += `
            <div class="growth-chart-container">
                <h3>=ï¿½ Growth Projections</h3>
                <div class="result-item" style="margin-bottom: 15px;">
                    <span>Current Cluster Utilization:</span>
                    <span class="result-value">${currentUtilization.toFixed(1)}%</span>
                </div>
                <div class="result-item" style="margin-bottom: 15px;">
                    <span>Annual Growth Rate:</span>
                    <span class="result-value">${annualGrowthRate}% (${monthlyGrowthRate.toFixed(2)}% monthly)</span>
                </div>
                <canvas id="growthChart" width="400" height="200"></canvas>
            </div>
            
            <div class="growth-projections">
                <div class="projection-card">
                    <h4>=ï¿½ Monthly Growth Analysis</h4>
        `;
        
        // Show key months
        const keyMonths = calc.growthProjections.filter((_, index) => 
            index === 0 || index === 3 || index === 6 || index === 12 || index === calc.growthProjections.length - 1
        ).slice(0, 6);
        
        keyMonths.forEach(proj => {
            resultsHTML += `
                <div class="projection-item">
                    <span>Month ${proj.month}: ${proj.maxUtilization.toFixed(1)}%</span>
                    <span>${proj.utilizationGrowth > 0 ? '+' : ''}${proj.utilizationGrowth.toFixed(1)}% growth</span>
                </div>
            `;
        });
        
        const totalGrowth = ((calc.growthProjections[calc.growthProjections.length - 1].totalInstances / calc.totalInstances - 1) * 100).toFixed(1);
        const finalUtilization = calc.growthProjections[calc.growthProjections.length - 1].maxUtilization;
        
        resultsHTML += `
                </div>
                
                <div class="projection-card">
                    <h4>=ï¿½ Growth Summary</h4>
                    <div class="projection-item">
                        <span>Total Instance Growth:</span>
                        <span class="result-value">${totalGrowth}%</span>
                    </div>
                    <div class="projection-item">
                        <span>Final Utilization:</span>
                        <span class="result-value">${finalUtilization.toFixed(1)}%</span>
                    </div>
                    <div class="projection-item">
                        <span>Utilization Increase:</span>
                        <span>+${(finalUtilization - currentUtilization).toFixed(1)}%</span>
                    </div>
                </div>
            </div>
        `;

        // Recommendations section - only show the first critical recommendation
        const firstCriticalRecommendation = calc.growthProjections.find(proj => 
            proj.showRecommendation && (proj.recommendation.includes('URGENT') || proj.recommendation.includes('WARNING') || proj.recommendation.includes('CAUTION'))
        );

        resultsHTML += `
            <div class="recommendation-card">
                <h4><ï¿½ Node Expansion Recommendation</h4>
        `;

        if (firstCriticalRecommendation) {
            let statusClass = '';
            if (firstCriticalRecommendation.recommendation.includes('URGENT')) statusClass = 'status-urgent';
            else if (firstCriticalRecommendation.recommendation.includes('WARNING')) statusClass = 'status-warning';
            else if (firstCriticalRecommendation.recommendation.includes('CAUTION')) statusClass = 'status-caution';
            else statusClass = 'status-ok';

            const nodesNeeded = firstCriticalRecommendation.recommendedNodesForNextMonth - firstCriticalRecommendation.workerNodesInMonth;

            resultsHTML += `
                <div class="recommendation-item">
                    <span>Month ${firstCriticalRecommendation.month}: ${firstCriticalRecommendation.maxUtilization.toFixed(1)}% utilization</span>
                    <span class="recommendation-status ${statusClass}">${firstCriticalRecommendation.recommendation}</span>
                </div>`;
            if (nodesNeeded > 0) {
                resultsHTML += `<div class="recommendation-item">
                        <span>Recommended Action:</span>
                        <span class="result-value">Add ${nodesNeeded} worker node(s)</span>
                    </div>`;
            }
            resultsHTML += `
                <div class="recommendation-item">
                    <span>Target Instances at that time:</span>
                    <span class="result-value">${firstCriticalRecommendation.totalInstances} instances</span>
                </div>
            `;
        } else {
            resultsHTML += `
                <div class="recommendation-item">
                    <span>No capacity expansion needed within projection period</span>
                    <span class="recommendation-status status-ok">OK: Current capacity sufficient</span>
                </div>
            `;
        }

        resultsHTML += '</div>';
    }

    resultsContainer.innerHTML = resultsHTML;

    // Create growth chart if projections exist
    if (calc.growthProjections) {
        setTimeout(() => {
            createGrowthChart(calc.growthProjections, calc.maxUtilization);
        }, 100);
    }

    // Show export buttons
    document.getElementById('exportBtn').style.display = 'inline-flex';
    document.getElementById('resourcesExportBtn').style.display = 'inline-flex';
}

function saveInputsToLocalStorage() {
    // Collect all sizing inputs
    const sizingInputs = {
        workloads: workloads, // 'workloads' global variable is already up-to-date
        cpuCores: document.getElementById('cpuCores').value,
        customizeSockets: document.getElementById('customizeSockets').checked,
        socketsPerNode: document.getElementById('socketsPerNode').value,
        cpuToVcpuRatio: document.getElementById('cpuToVcpuRatio').value,
        memoryPerNode: document.getElementById('memoryPerNode').value,
        maxUtilization: document.getElementById('maxUtilization').value,
        mergeMasters: document.getElementById('mergeMasters').checked,
        loggingStack: selectedLoggingStack,
        subscriptionType: selectedSubscriptionType,
        logVolumePerPod: document.getElementById('logVolumePerPod').value,
        logRetentionDays: document.getElementById('logRetentionDays').value,
        compressionRatio: document.getElementById('compressionRatio').value,
        replicationFactor: document.getElementById('replicationFactor').value,
        enableGrowth: document.getElementById('enableGrowth').checked,
        growthRate: document.getElementById('growthRate').value,
        projectionMonths: document.getElementById('projectionMonths').value,
    };

    // Collect all capacity inputs
    const capacityInputs = {
        desiredTotalCpu: document.getElementById('desiredTotalCpu').value,
        desiredTotalMemory: document.getElementById('desiredTotalMemory').value,
        capacityCpuCores: document.getElementById('capacityCpuCores').value,
        capacityMemoryPerNode: document.getElementById('capacityMemoryPerNode').value,
        capacityCustomizeSockets: document.getElementById('capacityCustomizeSockets').checked,
        capacitySocketsPerNode: document.getElementById('capacitySocketsPerNode').value,
        // The subscription type is shared, but let's read it from its own context
        capacitySubscriptionType: document.querySelector('input[name="capacitySubscriptionType"]:checked').value,
    };

    const dataToSave = {
        mode: currentMode,
        sizing: sizingInputs,
        capacity: capacityInputs
    };

    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
}

function loadInputsFromLocalStorage() {
    const savedDataJSON = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (!savedDataJSON) {
        initializeWorkloads(); // If no saved data, just start with a default workload
        return;
    }

    try {
        const savedData = JSON.parse(savedDataJSON);

        // Restore mode
        const modeSelector = document.getElementById('mode-selector');
        const modeOption = modeSelector.querySelector(`div[onclick*="'${savedData.mode}'"]`);
        if (modeOption) {
            switchMode(savedData.mode, modeOption);
        }

        // Restore Sizing Inputs
        const sizing = savedData.sizing;
        if (sizing) {
            document.getElementById('cpuCores').value = sizing.cpuCores;
            document.getElementById('customizeSockets').checked = sizing.customizeSockets;
            document.getElementById('socketsPerNode').value = sizing.socketsPerNode;
            toggleSocketInput(); // Update visibility
            document.getElementById('cpuToVcpuRatio').value = sizing.cpuToVcpuRatio;
            document.getElementById('memoryPerNode').value = sizing.memoryPerNode;
            document.getElementById('maxUtilization').value = sizing.maxUtilization;
            document.getElementById('mergeMasters').checked = sizing.mergeMasters;

            const logStackOption = document.querySelector(`div[onclick*="'${sizing.loggingStack}'"]`);
            if (logStackOption) selectLoggingStack(sizing.loggingStack, logStackOption);

            const subTypeOption = document.querySelector(`#subscription-type-selector div[onclick*="'${sizing.subscriptionType}'"]`);
            if (subTypeOption) selectSubscriptionType(sizing.subscriptionType, subTypeOption);

            document.getElementById('logVolumePerPod').value = sizing.logVolumePerPod;
            document.getElementById('logRetentionDays').value = sizing.logRetentionDays;
            document.getElementById('compressionRatio').value = sizing.compressionRatio;
            document.getElementById('replicationFactor').value = sizing.replicationFactor;

            document.getElementById('enableGrowth').checked = sizing.enableGrowth;
            toggleGrowthInputs(); // Update visibility
            document.getElementById('growthRate').value = sizing.growthRate;
            document.getElementById('projectionMonths').value = sizing.projectionMonths;

            // Restore workloads
            document.getElementById('workloads-container').innerHTML = '';
            workloadCounter = 0;
            workloads = [];
            if (sizing.workloads && sizing.workloads.length > 0) {
                sizing.workloads.forEach(workload => {
                    addWorkload(workload);
                });
                updateWorkloads(); // This will update the global 'workloads' array and check for VM subscription requirements
            } else {
                addWorkload(); // Add a default one if none were saved
            }
        }

        // Restore Capacity Inputs
        const capacity = savedData.capacity;
        if (capacity) {
            document.getElementById('desiredTotalCpu').value = capacity.desiredTotalCpu || 12;
            document.getElementById('desiredTotalMemory').value = capacity.desiredTotalMemory || 32;
            document.getElementById('capacityCpuCores').value = capacity.capacityCpuCores;
            document.getElementById('capacityMemoryPerNode').value = capacity.capacityMemoryPerNode;
            document.getElementById('capacityCustomizeSockets').checked = capacity.capacityCustomizeSockets;
            document.getElementById('capacitySocketsPerNode').value = capacity.capacitySocketsPerNode;
            toggleCapacitySocketInput(); // Update visibility

            const capSubTypeOption = document.querySelector(`#capacity-subscription-type-selector div[onclick*="'${capacity.capacitySubscriptionType}'"]`);
            if (capSubTypeOption) selectSubscriptionType(capacity.capacitySubscriptionType, capSubTypeOption);
        }
    } catch (e) {
        console.error("Failed to load saved data, resetting to defaults.", e);
        localStorage.removeItem(LOCAL_STORAGE_KEY);
        initializeWorkloads();
    }
}

function switchMode(mode, element) {
    currentMode = mode;
    
    document.getElementById('sizing-calculator-inputs').style.display = (mode === 'sizing') ? 'block' : 'none';
    document.getElementById('capacity-estimator-inputs').style.display = (mode === 'capacity') ? 'block' : 'none';

    // Update UI selection
    element.parentElement.querySelectorAll('.radio-option').forEach(option => {
        option.classList.remove('selected');
    });
    element.classList.add('selected');
    element.querySelector('input[type="radio"]').checked = true;

    // Clear results
    document.getElementById('results-container').innerHTML = `
        <div class="result-card">
            <h3><i class="icon-welcome"></i> Welcome!</h3>
            <p>Configure your options and click the button to see the results.</p>
        </div>
    `;
    document.getElementById('exportBtn').style.display = 'none';
    document.getElementById('resourcesExportBtn').style.display = 'none';
    document.getElementById('capacityExportBtn').style.display = 'none';
    saveInputsToLocalStorage();
}

function resetToDefaults() {
    if (!confirm('Are you sure you want to reset all inputs to their default values? This will clear any saved data.')) {
        return;
    }

    // Clear local storage
    localStorage.removeItem(LOCAL_STORAGE_KEY);

    // Reset Sizing Inputs
    document.getElementById('cpuCores').value = 8;
    document.getElementById('customizeSockets').checked = false;
    document.getElementById('socketsPerNode').value = 2;
    toggleSocketInput();
    document.getElementById('cpuToVcpuRatio').value = 2;
    document.getElementById('memoryPerNode').value = 32;
    document.getElementById('maxUtilization').value = 80;
    document.getElementById('mergeMasters').checked = false;

    selectLoggingStack('elasticsearch', document.querySelector('div[onclick*="\'elasticsearch\'"]'));
    selectSubscriptionType('core', document.querySelector('#subscription-type-selector div[onclick*="\'core\'"]'));

    document.getElementById('logVolumePerPod').value = 100;
    document.getElementById('logRetentionDays').value = 30;
    document.getElementById('compressionRatio').value = 3;
    document.getElementById('replicationFactor').value = 1;

    document.getElementById('enableGrowth').checked = false;
    toggleGrowthInputs();
    document.getElementById('growthRate').value = 50;
    document.getElementById('projectionMonths').value = 12;

    // Reset workloads
    document.getElementById('workloads-container').innerHTML = '';
    workloadCounter = 0;
    workloads = [];
    addWorkload();

    // Reset Capacity Inputs
    document.getElementById('desiredTotalCpu').value = 12;
    document.getElementById('desiredTotalMemory').value = 32;
    document.getElementById('capacityCpuCores').value = 8;
    document.getElementById('capacityMemoryPerNode').value = 32;
    document.getElementById('capacityCustomizeSockets').checked = false;
    document.getElementById('capacitySocketsPerNode').value = 2;
    toggleCapacitySocketInput();
    selectSubscriptionType('core', document.querySelector('#capacity-subscription-type-selector div[onclick*="\'core\'"]'));

    // Reset results
    document.getElementById('results-container').innerHTML = `
        <div class="result-card">
            <h3><i class="icon-welcome"></i> Welcome!</h3>
            <p>Inputs have been reset to default values.</p>
        </div>
    `;
    document.getElementById('exportBtn').style.display = 'none';

    alert('All inputs have been reset to their default values.');
}

function calculateWorkerNodesNeeded(desiredTotalCpu, desiredTotalMemory, cpuPerNode, memoryPerNode) {
    // Constants for calculations
    const cpuToVcpuRatio = 2; // Assuming hyperthreading
    const maxUtilization = 0.80; // Assuming 80% target
    const loggingStack = 'elasticsearch'; // Default logging stack
    
    // Per-node calculations
    const totalVcpuPerNode = cpuPerNode * cpuToVcpuRatio;
    const cpuReservation = calculateCpuReservation(cpuPerNode);
    const memoryReservation = calculateMemoryReservation(memoryPerNode);
    
    const availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
    const availableMemoryPerNode = memoryPerNode - memoryReservation;
    
    // Calculate usable resources considering max utilization
    const usableVcpuPerNode = availableVcpuPerNode * maxUtilization;
    const usableMemoryPerNode = availableMemoryPerNode * maxUtilization;
    
    // Calculate base worker nodes needed (before logging overhead)
    const nodesForCpu = Math.ceil(desiredTotalCpu / usableVcpuPerNode);
    const nodesForMemory = Math.ceil(desiredTotalMemory / usableMemoryPerNode);
    let baseWorkerNodes = Math.max(nodesForCpu, nodesForMemory, 3); // Minimum 3 nodes
    
    // Account for logging overhead and recalculate iteratively
    let finalWorkerNodes = baseWorkerNodes;
    let iterations = 0;
    const maxIterations = 10;
    
    while (iterations < maxIterations) {
        const loggingOverhead = getLoggingOverhead(loggingStack, finalWorkerNodes);
        
        // Calculate infra requirements based on current estimated cluster size
        const currentClusterSize = 3 + finalWorkerNodes; // 3 masters + workers
        const infraReqs = getInfrastructureRequirements(loggingStack, currentClusterSize);
        
        // Total requirements including logging and infra overhead
        let totalVcpuWithLogging = desiredTotalCpu + loggingOverhead.totalCpu + infraReqs.totalCpu;
        let totalMemoryWithLogging = desiredTotalMemory + loggingOverhead.totalMemory + infraReqs.totalMemory;
        
        // Calculate new worker node requirements
        const newNodesForCpu = Math.ceil(totalVcpuWithLogging / usableVcpuPerNode);
        const newNodesForMemory = Math.ceil(totalMemoryWithLogging / usableMemoryPerNode);
        let newWorkerNodes = Math.max(newNodesForCpu, newNodesForMemory, 3);
        
        if (newWorkerNodes === finalWorkerNodes) {
            break; // Converged
        }
        
        finalWorkerNodes = newWorkerNodes;
        iterations++;
    }
    
    return finalWorkerNodes;
}

function calculateCapacity() {
    // Get desired resource requirements
    const desiredTotalCpu = parseInt(document.getElementById('desiredTotalCpu').value) || 0;
    const desiredTotalMemory = parseInt(document.getElementById('desiredTotalMemory').value) || 0;
    
    // Get node specifications
    const cpuPerNode = parseInt(document.getElementById('capacityCpuCores').value) || 0;
    const memoryPerNode = parseInt(document.getElementById('capacityMemoryPerNode').value) || 0;

    if (desiredTotalCpu <= 0 || desiredTotalMemory <= 0 || cpuPerNode <= 0 || memoryPerNode <= 0) {
        alert('Please enter valid, positive numbers for all specifications.');
        return;
    }

    // Calculate worker nodes needed
    const workerNodesNeeded = calculateWorkerNodesNeeded(desiredTotalCpu, desiredTotalMemory, cpuPerNode, memoryPerNode);
    
    // Get subscription inputs
    const socketsPerNode = parseInt(document.getElementById('capacitySocketsPerNode').value) || 2;
    const subscriptionInfo = calculateSubscriptions(selectedSubscriptionType, workerNodesNeeded, cpuPerNode, socketsPerNode);

    const containerPreset = WORKLOAD_PRESETS.container;
    const vmPreset = WORKLOAD_PRESETS.vm;

    // --- Calculate Actual Usable Resources for the calculated cluster ---
    const cpuToVcpuRatio = 2; // Assuming hyperthreading
    const maxUtilization = 0.80; // Assuming 80% target
    const loggingStack = 'elasticsearch'; // Assuming ES

    // Per-node calculations
    const totalVcpuPerNode = cpuPerNode * cpuToVcpuRatio;
    const cpuReservation = calculateCpuReservation(cpuPerNode);
    const memoryReservation = calculateMemoryReservation(memoryPerNode);
    
    const availableVcpuPerNode = totalVcpuPerNode - cpuReservation;
    const availableMemoryPerNode = memoryPerNode - memoryReservation;

    // Total cluster resources available on workers
    let totalAvailableVcpu = workerNodesNeeded * availableVcpuPerNode;
    let totalAvailableMemory = workerNodesNeeded * availableMemoryPerNode;

    // Subtract logging overhead from the total pool
    const loggingOverhead = getLoggingOverhead(loggingStack, workerNodesNeeded);
    totalAvailableVcpu -= loggingOverhead.totalCpu;
    totalAvailableMemory -= loggingOverhead.totalMemory;

    // Apply max utilization to get the final usable pool for workloads
    const usableVcpu = totalAvailableVcpu * maxUtilization;
    const usableMemory = totalAvailableMemory * maxUtilization;

    // --- Calculate Capacity ---
    const containerCapacityByCpu = Math.floor(usableVcpu / containerPreset.vcpu);
    const containerCapacityByMem = Math.floor(usableMemory / containerPreset.memory);
    const containerCapacity = Math.min(containerCapacityByCpu, containerCapacityByMem);

    const vmCapacityByCpu = Math.floor(usableVcpu / vmPreset.vcpu);
    const vmCapacityByMem = Math.floor(usableMemory / vmPreset.memory);
    const vmCapacity = Math.min(vmCapacityByCpu, vmCapacityByMem);

    const results = {
        desiredTotalCpu,
        desiredTotalMemory,
        cpuPerNode,
        memoryPerNode,
        workerNodesNeeded,
        usableVcpu,
        usableMemory,
        containerPreset,
        containerCapacity,
        containerLimitingFactor: containerCapacityByCpu < containerCapacityByMem ? 'vCPU' : 'Memory',
        vmPreset,
        vmCapacity,
        vmLimitingFactor: vmCapacityByCpu < vmCapacityByMem ? 'vCPU' : 'Memory',
        subscriptionInfo
    };

    // Store results for export
    window.lastCapacityResults = results;
    
    displayCapacityResults(results);
}

function displayCapacityResults(results) {
    const resultsContainer = document.getElementById('results-container');

    const resultsHTML = `
        <div class="result-card" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);">
            <h3><i class="icon-calculate"></i> Worker Nodes Calculation</h3>
            <div class="result-item">
                <span><span class="status-icon"><i class="icon-server"></i></span>Required Worker Nodes:</span>
                <span class="result-value" style="font-size: 1.5rem;">${results.workerNodesNeeded}</span>
            </div>
            <div class="result-item">
                <span>Your Requirements:</span>
                <span class="result-value">${results.desiredTotalCpu} CPUs / ${results.desiredTotalMemory} GB RAM</span>
            </div>
            <div class="result-item">
                <span>Each Node Specs:</span>
                <span class="result-value">${results.cpuPerNode} Cores / ${results.memoryPerNode} GB RAM</span>
            </div>
            <div class="result-item">
                <span>Total Usable vCPU (for workloads):</span>
                <span class="result-value">${results.usableVcpu.toFixed(1)} vCPUs</span>
            </div>
            <div class="result-item">
                <span>Total Usable Memory (for workloads):</span>
                <span class="result-value">${results.usableMemory.toFixed(1)} GB</span>
            </div>
        </div>

        <div class="result-card">
            <h3><i class="icon-workload"></i> Estimated Container Capacity</h3>
            <div class="result-item">
                <span>Assumed Container Size:</span>
                <span class="result-value">${results.containerPreset.vcpu} vCPU / ${results.containerPreset.memory} GB RAM</span>
            </div>
            <div class="result-item">
                <span><strong>Estimated Containers:</strong></span>
                <span class="result-value" style="font-size: 1.5rem;">~ ${results.containerCapacity}</span>
            </div>
            <div class="result-item">
                <span>Limiting Resource:</span>
                <span class="result-value">${results.containerLimitingFactor}</span>
            </div>
        </div>

        ${results.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
            <div class="result-card">
                <h3><i class="icon-server"></i> Estimated VM Capacity (OpenShift Virtualization)</h3>
                <div class="result-item">
                    <span>Assumed VM Size:</span>
                    <span class="result-value">${results.vmPreset.vcpu} vCPU / ${results.vmPreset.memory} GB RAM</span>
                </div>
                <div class="result-item">
                    <span><strong>Estimated VMs:</strong></span>
                    <span class="result-value" style="font-size: 1.5rem;">~ ${results.vmCapacity}</span>
                </div>
                <div class="result-item">
                    <span>Limiting Resource:</span>
                    <span class="result-value">${results.vmLimitingFactor}</span>
                </div>
            </div>
        ` : `<div class="warning"><i class="icon-advanced"></i> <strong>VM Estimation Not Available:</strong> OpenShift Virtualization requires a socket-based subscription. Please select "Bare-metal (Socket-based)" to estimate VM capacity.</div>`}

        <div class="result-card">
            <h3><i class="icon-export"></i> OpenShift Subscription Estimate</h3>
            <div class="result-item">
                <span>Subscription Model:</span>
                <span class="result-value">${results.subscriptionInfo.type}</span>
            </div>
            <div class="result-item">
                <span>Total Billable Physical Cores (on ${results.workerNodesNeeded} worker nodes):</span>
                <span class="result-value">${results.subscriptionInfo.totalPhysicalCores} cores</span>
            </div>
            ${results.subscriptionInfo.type === 'Bare-metal (Socket-based)' ? `
            <div class="result-item">
                <span>Total Billable Sockets (on ${results.workerNodesNeeded} worker nodes):</span>
                <span class="result-value">${results.subscriptionInfo.totalSockets} sockets</span>
            </div>
            ` : ''}
            <div class="result-item">
                <span><strong>Required Subscriptions:</strong></span>
                <span class="result-value" style="font-size: 1.5rem;">${results.subscriptionInfo.count}</span>
            </div>
            <div class="warning" style="margin-top: 15px; padding: 10px; text-align: center; background: rgba(0,0,0,0.2);">
                <i class="icon-chart"></i> <strong>Calculation:</strong> ${results.subscriptionInfo.calculationMethod}
            </div>
        </div>

        <div class="warning">
            <i class="icon-chart"></i> <strong>Note:</strong> These are estimates based on a standard OpenShift deployment with dedicated master/infra nodes and typical overhead. For precise calculations, use the Advanced Resource Sizing mode.
        </div>
    `;

    resultsContainer.innerHTML = resultsHTML;
    document.getElementById('capacityExportBtn').style.display = 'inline-flex';
}

function exportCapacityDiagram() {
    if (!window.lastCapacityResults) {
        alert('Please calculate capacity first before generating diagram');
        return;
    }

    const results = window.lastCapacityResults;
    
    // Create a simple text-based diagram
    const diagram = `
OpenShift Capacity Planning Diagram
===================================

Requirements:
- Desired CPU: ${results.desiredTotalCpu} vCPUs
- Desired Memory: ${results.desiredTotalMemory} GB

Node Specifications:
- CPU per Node: ${results.cpuPerNode} cores
- Memory per Node: ${results.memoryPerNode} GB

Calculated Infrastructure:
âââââââââââââââââââââââââââââââââââââââ
â           Worker Nodes              â
â         (${results.workerNodesNeeded} nodes)              â
âââââââââââââââââââââââââââââââââââââââ¤
â  Node 1: ${results.cpuPerNode} cores / ${results.memoryPerNode} GB RAM    â
â  Node 2: ${results.cpuPerNode} cores / ${results.memoryPerNode} GB RAM    â
â  Node 3: ${results.cpuPerNode} cores / ${results.memoryPerNode} GB RAM    â
${results.workerNodesNeeded > 3 ? `â  ...                                â
â  Node ${results.workerNodesNeeded}: ${results.cpuPerNode} cores / ${results.memoryPerNode} GB RAM    â` : ''}
âââââââââââââââââââââââââââââââââââââââ

Capacity Estimates:
- Usable Resources: ${results.usableVcpu.toFixed(1)} vCPUs / ${results.usableMemory.toFixed(1)} GB
- Container Capacity: ~${results.containerCapacity} containers
- VM Capacity: ~${results.vmCapacity} VMs (if socket-based subscription)

Subscription Requirements:
- Model: ${results.subscriptionInfo.type}
- Required Subscriptions: ${results.subscriptionInfo.count}
    `;
    
    // Create and download the diagram as a text file
    const blob = new Blob([diagram], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `OpenShift_Capacity_Diagram_${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function exportResourcesDiagram() {
    if (!window.lastCalculationResults) {
        alert('Please calculate resources first before generating diagram');
        return;
    }

    const calc = window.lastCalculationResults;
    
    // Create a detailed text-based diagram
    const diagram = `
OpenShift Resource Planning Diagram
===================================

Workload Requirements:
${calc.workloads.map(w => `- ${w.name}: ${w.instances} instances (${(w.instances * w.vcpu).toFixed(1)} vCPUs / ${(w.instances * w.memory).toFixed(1)} GB)`).join('\n')}

Total Requirements: ${calc.totalVcpuNeeded.toFixed(1)} vCPUs / ${calc.totalMemoryNeeded.toFixed(1)} GB

Calculated Infrastructure:
âââââââââââââââââââââââââââââââââââââââ
â           Master Nodes              â
â         (${calc.mergeMasters ? '0 - merged' : calc.masterNodes} nodes)              â
${!calc.mergeMasters ? `âââââââââââââââââââââââââââââââââââââââ¤
â  Master 1: 2 vCPUs / 8 GB RAM       â
â  Master 2: 2 vCPUs / 8 GB RAM       â
â  Master 3: 2 vCPUs / 8 GB RAM       â` : ''}
âââââââââââââââââââââââââââââââââââââââ

âââââââââââââââââââââââââââââââââââââââ
â           Worker Nodes              â
â         (${calc.finalWorkerNodes} nodes)              â
âââââââââââââââââââââââââââââââââââââââ¤
â  Node 1: ${calc.cpuCores} cores / ${calc.memoryPerNode} GB RAM    â
â  Node 2: ${calc.cpuCores} cores / ${calc.memoryPerNode} GB RAM    â
â  Node 3: ${calc.cpuCores} cores / ${calc.memoryPerNode} GB RAM    â
${calc.finalWorkerNodes > 3 ? `â  ...                                â
â  Node ${calc.finalWorkerNodes}: ${calc.cpuCores} cores / ${calc.memoryPerNode} GB RAM    â` : ''}
âââââââââââââââââââââââââââââââââââââââ

Resource Allocation:
- Total Cluster Nodes: ${calc.totalClusterNodes}
- Worker Node Utilization: CPU ${calc.actualCpuUtilization.toFixed(1)}% / Memory ${calc.actualMemoryUtilization.toFixed(1)}%
- Logging Stack: ${calc.selectedLoggingStack}
- Infrastructure Overhead: ${calc.finalInfraOverhead.cpu.toFixed(1)} vCPUs / ${calc.finalInfraOverhead.memory.toFixed(1)} GB

Subscription Requirements:
- Model: ${calc.subscriptionInfo.type}
- Required Subscriptions: ${calc.subscriptionInfo.count}
- Calculation: ${calc.subscriptionInfo.calculationMethod}

Log Storage:
- Total Pods: ${calc.logStorage.totalPods}
- Daily Log Volume: ${(calc.logStorage.dailyRawLogVolumeMB / 1024).toFixed(1)} GB/day
- Required Storage: ${calc.logStorage.finalStorageRequirementGB.toFixed(1)} GB
    `;
    
    // Create and download the diagram as a text file
    const blob = new Blob([diagram], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `OpenShift_Resources_Diagram_${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

// Initialize
window.onload = function() {
    loadInputsFromLocalStorage();
};